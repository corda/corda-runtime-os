/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package net.corda.restclient.generated.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import net.corda.restclient.generated.models.PostMgmHoldingidentityshorthashDeclineRequestidRequest
import net.corda.restclient.generated.models.PutMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest

import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.databind.ObjectMapper

import net.corda.restclient.generated.infrastructure.ApiClient
import net.corda.restclient.generated.infrastructure.ApiResponse
import net.corda.restclient.generated.infrastructure.ClientException
import net.corda.restclient.generated.infrastructure.ClientError
import net.corda.restclient.generated.infrastructure.ServerException
import net.corda.restclient.generated.infrastructure.ServerError
import net.corda.restclient.generated.infrastructure.MultiValueMap
import net.corda.restclient.generated.infrastructure.PartConfig
import net.corda.restclient.generated.infrastructure.RequestConfig
import net.corda.restclient.generated.infrastructure.RequestMethod
import net.corda.restclient.generated.infrastructure.ResponseType
import net.corda.restclient.generated.infrastructure.Success
import net.corda.restclient.generated.infrastructure.toMultiValue

class MGMApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "/api/v5_3")
        }
    }

    /**
     * 
     * This API deletes a group approval rule for registrations including a pre-auth token.
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @param ruleid The ID of the group approval rule to be deleted.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteMgmHoldingidentityshorthashApprovalRulesPreauthRuleid(holdingidentityshorthash: kotlin.String, ruleid: kotlin.String) : Unit {
        val localVarResponse = deleteMgmHoldingidentityshorthashApprovalRulesPreauthRuleidWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, ruleid = ruleid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This API deletes a group approval rule for registrations including a pre-auth token.
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @param ruleid The ID of the group approval rule to be deleted.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteMgmHoldingidentityshorthashApprovalRulesPreauthRuleidWithHttpInfo(holdingidentityshorthash: kotlin.String, ruleid: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteMgmHoldingidentityshorthashApprovalRulesPreauthRuleidRequestConfig(holdingidentityshorthash = holdingidentityshorthash, ruleid = ruleid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteMgmHoldingidentityshorthashApprovalRulesPreauthRuleid
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @param ruleid The ID of the group approval rule to be deleted.
     * @return RequestConfig
     */
    fun deleteMgmHoldingidentityshorthashApprovalRulesPreauthRuleidRequestConfig(holdingidentityshorthash: kotlin.String, ruleid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/mgm/{holdingidentityshorthash}/approval/rules/preauth/{ruleid}".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())).replace("{"+"ruleid"+"}", encodeURIComponent(ruleid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This API deletes a previously added group approval rule.
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param ruleid The ID of the group approval rule to be deleted
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteMgmHoldingidentityshorthashApprovalRulesRuleid(holdingidentityshorthash: kotlin.String, ruleid: kotlin.String) : Unit {
        val localVarResponse = deleteMgmHoldingidentityshorthashApprovalRulesRuleidWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, ruleid = ruleid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This API deletes a previously added group approval rule.
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param ruleid The ID of the group approval rule to be deleted
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteMgmHoldingidentityshorthashApprovalRulesRuleidWithHttpInfo(holdingidentityshorthash: kotlin.String, ruleid: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteMgmHoldingidentityshorthashApprovalRulesRuleidRequestConfig(holdingidentityshorthash = holdingidentityshorthash, ruleid = ruleid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteMgmHoldingidentityshorthashApprovalRulesRuleid
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param ruleid The ID of the group approval rule to be deleted
     * @return RequestConfig
     */
    fun deleteMgmHoldingidentityshorthashApprovalRulesRuleidRequestConfig(holdingidentityshorthash: kotlin.String, ruleid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/mgm/{holdingidentityshorthash}/approval/rules/{ruleid}".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())).replace("{"+"ruleid"+"}", encodeURIComponent(ruleid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This API disallows a client certificate with a given subject to be used in mutual TLS connections.
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @param subject The certificate subject.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsSubject(holdingidentityshorthash: kotlin.String, subject: kotlin.String) : Unit {
        val localVarResponse = deleteMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsSubjectWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, subject = subject)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This API disallows a client certificate with a given subject to be used in mutual TLS connections.
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @param subject The certificate subject.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsSubjectWithHttpInfo(holdingidentityshorthash: kotlin.String, subject: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsSubjectRequestConfig(holdingidentityshorthash = holdingidentityshorthash, subject = subject)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsSubject
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @param subject The certificate subject.
     * @return RequestConfig
     */
    fun deleteMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsSubjectRequestConfig(holdingidentityshorthash: kotlin.String, subject: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/mgm/{holdingidentityshorthash}/mutual-tls/allowed-client-certificate-subjects/{subject}".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())).replace("{"+"subject"+"}", encodeURIComponent(subject.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Returns the version of the endpoint
     * @return kotlin.Int
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMgmGetprotocolversion() : kotlin.Int {
        val localVarResponse = getMgmGetprotocolversionWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Returns the version of the endpoint
     * @return ApiResponse<kotlin.Int?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMgmGetprotocolversionWithHttpInfo() : ApiResponse<kotlin.Int?> {
        val localVariableConfig = getMgmGetprotocolversionRequestConfig()

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMgmGetprotocolversion
     *
     * @return RequestConfig
     */
    fun getMgmGetprotocolversionRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/mgm/getprotocolversion",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This API retrieves the set of rules the group is currently configured with
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @return kotlin.collections.List<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMgmHoldingidentityshorthashApprovalRules(holdingidentityshorthash: kotlin.String) : kotlin.collections.List<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo> {
        val localVarResponse = getMgmHoldingidentityshorthashApprovalRulesWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This API retrieves the set of rules the group is currently configured with
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @return ApiResponse<kotlin.collections.List<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMgmHoldingidentityshorthashApprovalRulesWithHttpInfo(holdingidentityshorthash: kotlin.String) : ApiResponse<kotlin.collections.List<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo>?> {
        val localVariableConfig = getMgmHoldingidentityshorthashApprovalRulesRequestConfig(holdingidentityshorthash = holdingidentityshorthash)

        return request<Unit, kotlin.collections.List<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMgmHoldingidentityshorthashApprovalRules
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @return RequestConfig
     */
    fun getMgmHoldingidentityshorthashApprovalRulesRequestConfig(holdingidentityshorthash: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/mgm/{holdingidentityshorthash}/approval/rules".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This API retrieves the set of rules the group is currently configured with for registration request with a pre-auth token.
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @return kotlin.collections.List<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMgmHoldingidentityshorthashApprovalRulesPreauth(holdingidentityshorthash: kotlin.String) : kotlin.collections.List<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo> {
        val localVarResponse = getMgmHoldingidentityshorthashApprovalRulesPreauthWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This API retrieves the set of rules the group is currently configured with for registration request with a pre-auth token.
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @return ApiResponse<kotlin.collections.List<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMgmHoldingidentityshorthashApprovalRulesPreauthWithHttpInfo(holdingidentityshorthash: kotlin.String) : ApiResponse<kotlin.collections.List<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo>?> {
        val localVariableConfig = getMgmHoldingidentityshorthashApprovalRulesPreauthRequestConfig(holdingidentityshorthash = holdingidentityshorthash)

        return request<Unit, kotlin.collections.List<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMgmHoldingidentityshorthashApprovalRulesPreauth
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @return RequestConfig
     */
    fun getMgmHoldingidentityshorthashApprovalRulesPreauthRequestConfig(holdingidentityshorthash: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/mgm/{holdingidentityshorthash}/approval/rules/preauth".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This API retrieves the group policy from the MGM required to join the membership group.
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group to be joined
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMgmHoldingidentityshorthashInfo(holdingidentityshorthash: kotlin.String) : kotlin.String {
        val localVarResponse = getMgmHoldingidentityshorthashInfoWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This API retrieves the group policy from the MGM required to join the membership group.
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group to be joined
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMgmHoldingidentityshorthashInfoWithHttpInfo(holdingidentityshorthash: kotlin.String) : ApiResponse<kotlin.String?> {
        val localVariableConfig = getMgmHoldingidentityshorthashInfoRequestConfig(holdingidentityshorthash = holdingidentityshorthash)

        val response = request<Unit, Map<String, Any?>>(
            localVariableConfig
        )
        val responseAsSuccess = response as Success
        val responseString = ObjectMapper().writeValueAsString(responseAsSuccess.data)
        return Success(responseString)
    }

    /**
     * To obtain the request config of the operation getMgmHoldingidentityshorthashInfo
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group to be joined
     * @return RequestConfig
     */
    fun getMgmHoldingidentityshorthashInfoRequestConfig(holdingidentityshorthash: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/mgm/{holdingidentityshorthash}/info".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This API list the allowed  client certificates subjects to be used in mutual TLS connections.
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @return kotlin.collections.List<kotlin.String>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjects(holdingidentityshorthash: kotlin.String) : kotlin.collections.List<kotlin.String> {
        val localVarResponse = getMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.String>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This API list the allowed  client certificates subjects to be used in mutual TLS connections.
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @return ApiResponse<kotlin.collections.List<kotlin.String>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsWithHttpInfo(holdingidentityshorthash: kotlin.String) : ApiResponse<kotlin.collections.List<kotlin.String>?> {
        val localVariableConfig = getMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsRequestConfig(holdingidentityshorthash = holdingidentityshorthash)

        return request<Unit, kotlin.collections.List<kotlin.String>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjects
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @return RequestConfig
     */
    fun getMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsRequestConfig(holdingidentityshorthash: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/mgm/{holdingidentityshorthash}/mutual-tls/allowed-client-certificate-subjects".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param holdingidentityshorthash 
     * @param ownerx500name  (optional)
     * @param preauthtokenid  (optional)
     * @param viewinactive  (optional)
     * @return kotlin.collections.List<net.corda.membership.rest.v1.types.response.PreAuthToken>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMgmHoldingidentityshorthashPreauthtoken(holdingidentityshorthash: kotlin.String, ownerx500name: kotlin.String? = null, preauthtokenid: kotlin.String? = null, viewinactive: kotlin.Boolean? = null) : kotlin.collections.List<net.corda.membership.rest.v1.types.response.PreAuthToken> {
        val localVarResponse = getMgmHoldingidentityshorthashPreauthtokenWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, ownerx500name = ownerx500name, preauthtokenid = preauthtokenid, viewinactive = viewinactive)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<net.corda.membership.rest.v1.types.response.PreAuthToken>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param holdingidentityshorthash 
     * @param ownerx500name  (optional)
     * @param preauthtokenid  (optional)
     * @param viewinactive  (optional)
     * @return ApiResponse<kotlin.collections.List<net.corda.membership.rest.v1.types.response.PreAuthToken>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMgmHoldingidentityshorthashPreauthtokenWithHttpInfo(holdingidentityshorthash: kotlin.String, ownerx500name: kotlin.String?, preauthtokenid: kotlin.String?, viewinactive: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<net.corda.membership.rest.v1.types.response.PreAuthToken>?> {
        val localVariableConfig = getMgmHoldingidentityshorthashPreauthtokenRequestConfig(holdingidentityshorthash = holdingidentityshorthash, ownerx500name = ownerx500name, preauthtokenid = preauthtokenid, viewinactive = viewinactive)

        return request<Unit, kotlin.collections.List<net.corda.membership.rest.v1.types.response.PreAuthToken>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMgmHoldingidentityshorthashPreauthtoken
     *
     * @param holdingidentityshorthash 
     * @param ownerx500name  (optional)
     * @param preauthtokenid  (optional)
     * @param viewinactive  (optional)
     * @return RequestConfig
     */
    fun getMgmHoldingidentityshorthashPreauthtokenRequestConfig(holdingidentityshorthash: kotlin.String, ownerx500name: kotlin.String?, preauthtokenid: kotlin.String?, viewinactive: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ownerx500name != null) {
                    put("ownerx500name", listOf(ownerx500name.toString()))
                }
                if (preauthtokenid != null) {
                    put("preauthtokenid", listOf(preauthtokenid.toString()))
                }
                if (viewinactive != null) {
                    put("viewinactive", listOf(viewinactive.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/mgm/{holdingidentityshorthash}/preauthtoken".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param requestsubjectx500name X.500 name of the requesting member (optional)
     * @param viewhistoric Include completed (historic) requests if set to &#39;true&#39; (optional)
     * @return kotlin.collections.List<net.corda.membership.rest.v1.types.response.RestRegistrationRequestStatus>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMgmHoldingidentityshorthashRegistrations(holdingidentityshorthash: kotlin.String, requestsubjectx500name: kotlin.String? = null, viewhistoric: kotlin.Boolean? = null) : kotlin.collections.List<net.corda.membership.rest.v1.types.response.RestRegistrationRequestStatus> {
        val localVarResponse = getMgmHoldingidentityshorthashRegistrationsWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, requestsubjectx500name = requestsubjectx500name, viewhistoric = viewhistoric)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<net.corda.membership.rest.v1.types.response.RestRegistrationRequestStatus>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param requestsubjectx500name X.500 name of the requesting member (optional)
     * @param viewhistoric Include completed (historic) requests if set to &#39;true&#39; (optional)
     * @return ApiResponse<kotlin.collections.List<net.corda.membership.rest.v1.types.response.RestRegistrationRequestStatus>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMgmHoldingidentityshorthashRegistrationsWithHttpInfo(holdingidentityshorthash: kotlin.String, requestsubjectx500name: kotlin.String?, viewhistoric: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<net.corda.membership.rest.v1.types.response.RestRegistrationRequestStatus>?> {
        val localVariableConfig = getMgmHoldingidentityshorthashRegistrationsRequestConfig(holdingidentityshorthash = holdingidentityshorthash, requestsubjectx500name = requestsubjectx500name, viewhistoric = viewhistoric)

        return request<Unit, kotlin.collections.List<net.corda.membership.rest.v1.types.response.RestRegistrationRequestStatus>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMgmHoldingidentityshorthashRegistrations
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param requestsubjectx500name X.500 name of the requesting member (optional)
     * @param viewhistoric Include completed (historic) requests if set to &#39;true&#39; (optional)
     * @return RequestConfig
     */
    fun getMgmHoldingidentityshorthashRegistrationsRequestConfig(holdingidentityshorthash: kotlin.String, requestsubjectx500name: kotlin.String?, viewhistoric: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (requestsubjectx500name != null) {
                    put("requestsubjectx500name", listOf(requestsubjectx500name.toString()))
                }
                if (viewhistoric != null) {
                    put("viewhistoric", listOf(viewhistoric.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/mgm/{holdingidentityshorthash}/registrations".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This endpoint enables you to activate a previously suspended member.
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param netCordaMembershipRestV1TypesRequestSuspensionActivationParameters requestBody
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postMgmHoldingidentityshorthashActivate(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestSuspensionActivationParameters: net.corda.membership.rest.v1.types.request.SuspensionActivationParameters) : Unit {
        val localVarResponse = postMgmHoldingidentityshorthashActivateWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, netCordaMembershipRestV1TypesRequestSuspensionActivationParameters = netCordaMembershipRestV1TypesRequestSuspensionActivationParameters)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This endpoint enables you to activate a previously suspended member.
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param netCordaMembershipRestV1TypesRequestSuspensionActivationParameters requestBody
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postMgmHoldingidentityshorthashActivateWithHttpInfo(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestSuspensionActivationParameters: net.corda.membership.rest.v1.types.request.SuspensionActivationParameters) : ApiResponse<Unit?> {
        val localVariableConfig = postMgmHoldingidentityshorthashActivateRequestConfig(holdingidentityshorthash = holdingidentityshorthash, netCordaMembershipRestV1TypesRequestSuspensionActivationParameters = netCordaMembershipRestV1TypesRequestSuspensionActivationParameters)

        return request<net.corda.membership.rest.v1.types.request.SuspensionActivationParameters, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postMgmHoldingidentityshorthashActivate
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param netCordaMembershipRestV1TypesRequestSuspensionActivationParameters requestBody
     * @return RequestConfig
     */
    fun postMgmHoldingidentityshorthashActivateRequestConfig(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestSuspensionActivationParameters: net.corda.membership.rest.v1.types.request.SuspensionActivationParameters) : RequestConfig<net.corda.membership.rest.v1.types.request.SuspensionActivationParameters> {
        val localVariableBody = netCordaMembershipRestV1TypesRequestSuspensionActivationParameters
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/mgm/{holdingidentityshorthash}/activate".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This API adds a rule to the set of group approval rules.
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams requestBody
     * @return net.corda.membership.rest.v1.types.response.ApprovalRuleInfo
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postMgmHoldingidentityshorthashApprovalRules(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams: net.corda.membership.rest.v1.types.request.ApprovalRuleRequestParams) : net.corda.membership.rest.v1.types.response.ApprovalRuleInfo {
        val localVarResponse = postMgmHoldingidentityshorthashApprovalRulesWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams = netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as net.corda.membership.rest.v1.types.response.ApprovalRuleInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This API adds a rule to the set of group approval rules.
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams requestBody
     * @return ApiResponse<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postMgmHoldingidentityshorthashApprovalRulesWithHttpInfo(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams: net.corda.membership.rest.v1.types.request.ApprovalRuleRequestParams) : ApiResponse<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo?> {
        val localVariableConfig = postMgmHoldingidentityshorthashApprovalRulesRequestConfig(holdingidentityshorthash = holdingidentityshorthash, netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams = netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams)

        return request<net.corda.membership.rest.v1.types.request.ApprovalRuleRequestParams, net.corda.membership.rest.v1.types.response.ApprovalRuleInfo>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postMgmHoldingidentityshorthashApprovalRules
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams requestBody
     * @return RequestConfig
     */
    fun postMgmHoldingidentityshorthashApprovalRulesRequestConfig(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams: net.corda.membership.rest.v1.types.request.ApprovalRuleRequestParams) : RequestConfig<net.corda.membership.rest.v1.types.request.ApprovalRuleRequestParams> {
        val localVariableBody = netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/mgm/{holdingidentityshorthash}/approval/rules".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This API adds a rule to the set of group approval rules for registrations including a pre-auth token.
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @param netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams requestBody
     * @return net.corda.membership.rest.v1.types.response.ApprovalRuleInfo
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postMgmHoldingidentityshorthashApprovalRulesPreauth(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams: net.corda.membership.rest.v1.types.request.ApprovalRuleRequestParams) : net.corda.membership.rest.v1.types.response.ApprovalRuleInfo {
        val localVarResponse = postMgmHoldingidentityshorthashApprovalRulesPreauthWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams = netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as net.corda.membership.rest.v1.types.response.ApprovalRuleInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This API adds a rule to the set of group approval rules for registrations including a pre-auth token.
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @param netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams requestBody
     * @return ApiResponse<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postMgmHoldingidentityshorthashApprovalRulesPreauthWithHttpInfo(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams: net.corda.membership.rest.v1.types.request.ApprovalRuleRequestParams) : ApiResponse<net.corda.membership.rest.v1.types.response.ApprovalRuleInfo?> {
        val localVariableConfig = postMgmHoldingidentityshorthashApprovalRulesPreauthRequestConfig(holdingidentityshorthash = holdingidentityshorthash, netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams = netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams)

        return request<net.corda.membership.rest.v1.types.request.ApprovalRuleRequestParams, net.corda.membership.rest.v1.types.response.ApprovalRuleInfo>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postMgmHoldingidentityshorthashApprovalRulesPreauth
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @param netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams requestBody
     * @return RequestConfig
     */
    fun postMgmHoldingidentityshorthashApprovalRulesPreauthRequestConfig(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams: net.corda.membership.rest.v1.types.request.ApprovalRuleRequestParams) : RequestConfig<net.corda.membership.rest.v1.types.request.ApprovalRuleRequestParams> {
        val localVariableBody = netCordaMembershipRestV1TypesRequestApprovalRuleRequestParams
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/mgm/{holdingidentityshorthash}/approval/rules/preauth".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param requestid ID of the registration request
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postMgmHoldingidentityshorthashApproveRequestid(holdingidentityshorthash: kotlin.String, requestid: kotlin.String) : Unit {
        val localVarResponse = postMgmHoldingidentityshorthashApproveRequestidWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, requestid = requestid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param requestid ID of the registration request
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postMgmHoldingidentityshorthashApproveRequestidWithHttpInfo(holdingidentityshorthash: kotlin.String, requestid: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = postMgmHoldingidentityshorthashApproveRequestidRequestConfig(holdingidentityshorthash = holdingidentityshorthash, requestid = requestid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postMgmHoldingidentityshorthashApproveRequestid
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param requestid ID of the registration request
     * @return RequestConfig
     */
    fun postMgmHoldingidentityshorthashApproveRequestidRequestConfig(holdingidentityshorthash: kotlin.String, requestid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/mgm/{holdingidentityshorthash}/approve/{requestid}".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())).replace("{"+"requestid"+"}", encodeURIComponent(requestid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param requestid ID of the registration request
     * @param postMgmHoldingidentityshorthashDeclineRequestidRequest requestBody
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postMgmHoldingidentityshorthashDeclineRequestid(holdingidentityshorthash: kotlin.String, requestid: kotlin.String, postMgmHoldingidentityshorthashDeclineRequestidRequest: PostMgmHoldingidentityshorthashDeclineRequestidRequest) : Unit {
        val localVarResponse = postMgmHoldingidentityshorthashDeclineRequestidWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, requestid = requestid, postMgmHoldingidentityshorthashDeclineRequestidRequest = postMgmHoldingidentityshorthashDeclineRequestidRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param requestid ID of the registration request
     * @param postMgmHoldingidentityshorthashDeclineRequestidRequest requestBody
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postMgmHoldingidentityshorthashDeclineRequestidWithHttpInfo(holdingidentityshorthash: kotlin.String, requestid: kotlin.String, postMgmHoldingidentityshorthashDeclineRequestidRequest: PostMgmHoldingidentityshorthashDeclineRequestidRequest) : ApiResponse<Unit?> {
        val localVariableConfig = postMgmHoldingidentityshorthashDeclineRequestidRequestConfig(holdingidentityshorthash = holdingidentityshorthash, requestid = requestid, postMgmHoldingidentityshorthashDeclineRequestidRequest = postMgmHoldingidentityshorthashDeclineRequestidRequest)

        return request<PostMgmHoldingidentityshorthashDeclineRequestidRequest, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postMgmHoldingidentityshorthashDeclineRequestid
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param requestid ID of the registration request
     * @param postMgmHoldingidentityshorthashDeclineRequestidRequest requestBody
     * @return RequestConfig
     */
    fun postMgmHoldingidentityshorthashDeclineRequestidRequestConfig(holdingidentityshorthash: kotlin.String, requestid: kotlin.String, postMgmHoldingidentityshorthashDeclineRequestidRequest: PostMgmHoldingidentityshorthashDeclineRequestidRequest) : RequestConfig<PostMgmHoldingidentityshorthashDeclineRequestidRequest> {
        val localVariableBody = postMgmHoldingidentityshorthashDeclineRequestidRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/mgm/{holdingidentityshorthash}/decline/{requestid}".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())).replace("{"+"requestid"+"}", encodeURIComponent(requestid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This API allows you to make changes to the group parameters by submitting an updated version of the group parameters.
     * @param holdingidentityshorthash The holding identity ID of the MGM
     * @param netCordaMembershipRestV1TypesRestGroupParameters requestBody
     * @return net.corda.membership.rest.v1.types.RestGroupParameters
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postMgmHoldingidentityshorthashGroupParameters(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRestGroupParameters: net.corda.membership.rest.v1.types.RestGroupParameters) : net.corda.membership.rest.v1.types.RestGroupParameters {
        val localVarResponse = postMgmHoldingidentityshorthashGroupParametersWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, netCordaMembershipRestV1TypesRestGroupParameters = netCordaMembershipRestV1TypesRestGroupParameters)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as net.corda.membership.rest.v1.types.RestGroupParameters
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This API allows you to make changes to the group parameters by submitting an updated version of the group parameters.
     * @param holdingidentityshorthash The holding identity ID of the MGM
     * @param netCordaMembershipRestV1TypesRestGroupParameters requestBody
     * @return ApiResponse<net.corda.membership.rest.v1.types.RestGroupParameters?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postMgmHoldingidentityshorthashGroupParametersWithHttpInfo(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRestGroupParameters: net.corda.membership.rest.v1.types.RestGroupParameters) : ApiResponse<net.corda.membership.rest.v1.types.RestGroupParameters?> {
        val localVariableConfig = postMgmHoldingidentityshorthashGroupParametersRequestConfig(holdingidentityshorthash = holdingidentityshorthash, netCordaMembershipRestV1TypesRestGroupParameters = netCordaMembershipRestV1TypesRestGroupParameters)

        return request<net.corda.membership.rest.v1.types.RestGroupParameters, net.corda.membership.rest.v1.types.RestGroupParameters>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postMgmHoldingidentityshorthashGroupParameters
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM
     * @param netCordaMembershipRestV1TypesRestGroupParameters requestBody
     * @return RequestConfig
     */
    fun postMgmHoldingidentityshorthashGroupParametersRequestConfig(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRestGroupParameters: net.corda.membership.rest.v1.types.RestGroupParameters) : RequestConfig<net.corda.membership.rest.v1.types.RestGroupParameters> {
        val localVariableBody = netCordaMembershipRestV1TypesRestGroupParameters
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/mgm/{holdingidentityshorthash}/group-parameters".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param holdingidentityshorthash 
     * @param netCordaMembershipRestV1TypesRequestPreAuthTokenRequest requestBody
     * @return net.corda.membership.rest.v1.types.response.PreAuthToken
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postMgmHoldingidentityshorthashPreauthtoken(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestPreAuthTokenRequest: net.corda.membership.rest.v1.types.request.PreAuthTokenRequest) : net.corda.membership.rest.v1.types.response.PreAuthToken {
        val localVarResponse = postMgmHoldingidentityshorthashPreauthtokenWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, netCordaMembershipRestV1TypesRequestPreAuthTokenRequest = netCordaMembershipRestV1TypesRequestPreAuthTokenRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as net.corda.membership.rest.v1.types.response.PreAuthToken
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param holdingidentityshorthash 
     * @param netCordaMembershipRestV1TypesRequestPreAuthTokenRequest requestBody
     * @return ApiResponse<net.corda.membership.rest.v1.types.response.PreAuthToken?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postMgmHoldingidentityshorthashPreauthtokenWithHttpInfo(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestPreAuthTokenRequest: net.corda.membership.rest.v1.types.request.PreAuthTokenRequest) : ApiResponse<net.corda.membership.rest.v1.types.response.PreAuthToken?> {
        val localVariableConfig = postMgmHoldingidentityshorthashPreauthtokenRequestConfig(holdingidentityshorthash = holdingidentityshorthash, netCordaMembershipRestV1TypesRequestPreAuthTokenRequest = netCordaMembershipRestV1TypesRequestPreAuthTokenRequest)

        return request<net.corda.membership.rest.v1.types.request.PreAuthTokenRequest, net.corda.membership.rest.v1.types.response.PreAuthToken>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postMgmHoldingidentityshorthashPreauthtoken
     *
     * @param holdingidentityshorthash 
     * @param netCordaMembershipRestV1TypesRequestPreAuthTokenRequest requestBody
     * @return RequestConfig
     */
    fun postMgmHoldingidentityshorthashPreauthtokenRequestConfig(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestPreAuthTokenRequest: net.corda.membership.rest.v1.types.request.PreAuthTokenRequest) : RequestConfig<net.corda.membership.rest.v1.types.request.PreAuthTokenRequest> {
        val localVariableBody = netCordaMembershipRestV1TypesRequestPreAuthTokenRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/mgm/{holdingidentityshorthash}/preauthtoken".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * The suspend endpoint enables you to suspend a member.
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param netCordaMembershipRestV1TypesRequestSuspensionActivationParameters requestBody
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postMgmHoldingidentityshorthashSuspend(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestSuspensionActivationParameters: net.corda.membership.rest.v1.types.request.SuspensionActivationParameters) : Unit {
        val localVarResponse = postMgmHoldingidentityshorthashSuspendWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, netCordaMembershipRestV1TypesRequestSuspensionActivationParameters = netCordaMembershipRestV1TypesRequestSuspensionActivationParameters)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * The suspend endpoint enables you to suspend a member.
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param netCordaMembershipRestV1TypesRequestSuspensionActivationParameters requestBody
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postMgmHoldingidentityshorthashSuspendWithHttpInfo(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestSuspensionActivationParameters: net.corda.membership.rest.v1.types.request.SuspensionActivationParameters) : ApiResponse<Unit?> {
        val localVariableConfig = postMgmHoldingidentityshorthashSuspendRequestConfig(holdingidentityshorthash = holdingidentityshorthash, netCordaMembershipRestV1TypesRequestSuspensionActivationParameters = netCordaMembershipRestV1TypesRequestSuspensionActivationParameters)

        return request<net.corda.membership.rest.v1.types.request.SuspensionActivationParameters, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postMgmHoldingidentityshorthashSuspend
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM of the membership group
     * @param netCordaMembershipRestV1TypesRequestSuspensionActivationParameters requestBody
     * @return RequestConfig
     */
    fun postMgmHoldingidentityshorthashSuspendRequestConfig(holdingidentityshorthash: kotlin.String, netCordaMembershipRestV1TypesRequestSuspensionActivationParameters: net.corda.membership.rest.v1.types.request.SuspensionActivationParameters) : RequestConfig<net.corda.membership.rest.v1.types.request.SuspensionActivationParameters> {
        val localVariableBody = netCordaMembershipRestV1TypesRequestSuspensionActivationParameters
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/mgm/{holdingidentityshorthash}/suspend".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This API allows a client certificate with a given subject to be used in mutual TLS connections.
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @param subject The certificate subject.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun putMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsSubject(holdingidentityshorthash: kotlin.String, subject: kotlin.String) : Unit {
        val localVarResponse = putMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsSubjectWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, subject = subject)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This API allows a client certificate with a given subject to be used in mutual TLS connections.
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @param subject The certificate subject.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun putMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsSubjectWithHttpInfo(holdingidentityshorthash: kotlin.String, subject: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = putMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsSubjectRequestConfig(holdingidentityshorthash = holdingidentityshorthash, subject = subject)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation putMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsSubject
     *
     * @param holdingidentityshorthash The holding identity ID of the MGM.
     * @param subject The certificate subject.
     * @return RequestConfig
     */
    fun putMgmHoldingidentityshorthashMutualTlsAllowedClientCertificateSubjectsSubjectRequestConfig(holdingidentityshorthash: kotlin.String, subject: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/mgm/{holdingidentityshorthash}/mutual-tls/allowed-client-certificate-subjects/{subject}".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())).replace("{"+"subject"+"}", encodeURIComponent(subject.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param holdingidentityshorthash 
     * @param preauthtokenid 
     * @param putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest requestBody (optional)
     * @return net.corda.membership.rest.v1.types.response.PreAuthToken
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenid(holdingidentityshorthash: kotlin.String, preauthtokenid: kotlin.String, putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest: PutMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest? = null) : net.corda.membership.rest.v1.types.response.PreAuthToken {
        val localVarResponse = putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidWithHttpInfo(holdingidentityshorthash = holdingidentityshorthash, preauthtokenid = preauthtokenid, putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest = putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as net.corda.membership.rest.v1.types.response.PreAuthToken
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param holdingidentityshorthash 
     * @param preauthtokenid 
     * @param putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest requestBody (optional)
     * @return ApiResponse<net.corda.membership.rest.v1.types.response.PreAuthToken?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidWithHttpInfo(holdingidentityshorthash: kotlin.String, preauthtokenid: kotlin.String, putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest: PutMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest?) : ApiResponse<net.corda.membership.rest.v1.types.response.PreAuthToken?> {
        val localVariableConfig = putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequestConfig(holdingidentityshorthash = holdingidentityshorthash, preauthtokenid = preauthtokenid, putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest = putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest)

        return request<PutMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest, net.corda.membership.rest.v1.types.response.PreAuthToken>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenid
     *
     * @param holdingidentityshorthash 
     * @param preauthtokenid 
     * @param putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest requestBody (optional)
     * @return RequestConfig
     */
    fun putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequestConfig(holdingidentityshorthash: kotlin.String, preauthtokenid: kotlin.String, putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest: PutMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest?) : RequestConfig<PutMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest> {
        val localVariableBody = putMgmHoldingidentityshorthashPreauthtokenRevokePreauthtokenidRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/mgm/{holdingidentityshorthash}/preauthtoken/revoke/{preauthtokenid}".replace("{"+"holdingidentityshorthash"+"}", encodeURIComponent(holdingidentityshorthash.toString())).replace("{"+"preauthtokenid"+"}", encodeURIComponent(preauthtokenid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
