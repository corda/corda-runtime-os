@Library('corda-shared-build-pipeline-steps@5.0') _


import groovy.transform.Field

@Field
String k8sNamespace = "run-${UUID.randomUUID().toString()}"

/*
 * Jenkins agent label to build on
 */
String agentLabel = 'docker'

/*
 * Docker label to use with worker base image
 */
String dockerLabel = '11'

/*
 * architecture string for Corda images
 */
String architectureTag = ''

/*
 * architecture for Kubernetes workers during E2E tests
 */
String e2eArchitecture = 'amd64'

switch (params.BUILD_ARCH) {
    case '':
    case null:
    case 'amd64':
        break;
    case 'arm64':
        agentLabel = 'arm64'
        dockerLabel = 'arm64-11'
        architectureTag = 'arm64-'
        e2eArchitecture = 'arm64'
        break
    default:
        error """\
                Not supported value for pipeline parameter 'BUILD_ARCH': '${params.BUILD_ARCH}'.
                One of 'amd64' (default) or 'arm64' is allowed.
            """.stripIndent()
        break
}


pipeline {
    agent {
        docker {
            image "build-zulu-openjdk:${dockerLabel}"
            label "${agentLabel}"
            registryUrl 'https://engineering-docker.software.r3.com/'
            registryCredentialsId 'artifactory-credentials'
            // Volume used to mount storage from the host as a volume to persist the cache between builds
            // Additional hosts used to facilitate access to Kafka
            args '-v /tmp:/host_tmp'
            // make sure build image is always fresh
            alwaysPull true
        }
    }

    parameters {
        string(name: 'BUILD_REV', defaultValue: '', description: 'Short git hash of the build revision to test - leave blank to test unstable')
        choice(name: 'BUILD_ARCH', choices: ['amd64', 'arm64'], description: 'Build architecture')
        booleanParam(name: 'KEEP_NS', defaultValue: false, description: 'Determines if the k8s Namespace is to be preserved or deleted at the end of the build.')
        string(name: 'COMMIT_TO_CHECKOUT', defaultValue: '', description: 'Commit ID to check out of SCM - leave blank to take head of current branch')
    }

    environment {
        ARTIFACTORY_CREDENTIALS = credentials('artifactory-credentials')
        BASE_IMAGE = getBaseImage(params.BUILD_REV, architectureTag)
        BUILD_CACHE_CREDENTIALS = credentials('gradle-ent-cache-credentials')
        BUILD_CACHE_USERNAME = "${env.BUILD_CACHE_CREDENTIALS_USR}"
        BUILD_CACHE_PASSWORD = "${env.BUILD_CACHE_CREDENTIALS_PSW}"
        CORDA_ARTIFACTORY_USERNAME = "${env.ARTIFACTORY_CREDENTIALS_USR}"
        CORDA_ARTIFACTORY_PASSWORD = "${env.ARTIFACTORY_CREDENTIALS_PSW}"
        CORDA_USE_CACHE = "corda-remotes"
        KUBECONFIG = credentials("e2e-tests-credentials")
        CORDA_CLI_USER_HOME = "/tmp/corda-cli-home"
        CORDA_GRADLE_SCAN_KEY = credentials('gradle-build-scans-key')
        GRADLE_USER_HOME = "/host_tmp/gradle"
        CORDA_REVISION = "${env.GIT_COMMIT}"
        NAMESPACE = "$k8sNamespace"
        CLUSTER_NAME = "eks-e2e.e2e.awsdev.r3.com"
        HELM_CONFIG_HOME = "/tmp/helm"
        HELM_REPOSITORY_CACHE = "/host_tmp/helm/repository"
        GRADLE_PERFORMANCE_TUNING = "--parallel -Dscan.tag.E2E -Dscan.tag.${env.NAMESPACE} --build-cache"
        E2E_CLUSTER_A_RPC_PORT=8887
        E2E_CLUSTER_B_RPC_PORT=8888
        E2E_CLUSTER_C_RPC_PORT=8889
        E2E_CLUSTER_A_P2P_HOST="corda-alice-p2p-gateway-worker.${NAMESPACE}.svc.cluster.local"
        E2E_CLUSTER_B_P2P_HOST="corda-bob-p2p-gateway-worker.${NAMESPACE}.svc.cluster.local"
        E2E_CLUSTER_C_P2P_HOST="corda-caroline-p2p-gateway-worker.${NAMESPACE}.svc.cluster.local"
        E2E_BRANCH_LABEL = "${sanitizedBranchName()}"
        E2E_WORKER_ARCH = "${e2eArchitecture}"
    }

    options {
        buildDiscarder(logRotator(daysToKeepStr: '14', artifactDaysToKeepStr: '14'))
        timeout(time: 45, unit: 'MINUTES')
        timestamps()
    }

    stages {
        stage('check out') {
            steps {
                script {
                    if (params.COMMIT_TO_CHECKOUT && env.CHANGE_ID == null) {  // CHANGE_ID only populated in PRs
                        echo "Checking out commit ID from upstream job ${params.COMMIT_TO_CHECKOUT}"
                        sh 'git checkout "$COMMIT_TO_CHECKOUT"'
                    } else {
                        echo "Checking out Head revision of ${env.BRANCH_NAME} and merging into ${env.CHANGE_TARGET}"
                    }
                }
            }
        }
        stage ('Create namespace') {
            steps {
                sh '''\
                    kubectl create ns "${NAMESPACE}"
                    kubectl label ns "${NAMESPACE}" namespace-type=corda-e2e --overwrite=true
                    kubectl label ns "${NAMESPACE}" branch="${E2E_BRANCH_LABEL}" --overwrite=true
                    kubectl label ns "${NAMESPACE}" arch="${E2E_WORKER_ARCH}" --overwrite=true
                    kubectl label ns "${NAMESPACE}" JenkinsBuildNumber="${BUILD_NUMBER}" --overwrite=true
                '''.stripIndent()
            }
        }
        stage('Install kafka as prereqs') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'artifactory-credentials', passwordVariable: 'PASSWORD', usernameVariable: 'USER')]) {
                    sh '''#!/bin/bash
                        echo "${PASSWORD}" | helm registry login corda-os-docker.software.r3.com -u "${USER}" --password-stdin
                        helm install prereqs oci://corda-os-docker.software.r3.com/helm-charts/corda-dev \
                            -f .ci/e2eTests/prereqs.yaml -f .ci/e2eTests/prereqs-eks.yaml --set postgresql.enabled=false -n "${NAMESPACE}" --wait --timeout 600s
                        KAFKA_PASSWORDS=$(kubectl get secret prereqs-kafka-jaas -n "${NAMESPACE}" -o go-template="{{ index .data \\\"client-passwords\\\" | base64decode }}")
                        IFS=',' read -r -a KAFKA_PASSWORDS_ARRAY <<< "$KAFKA_PASSWORDS"
                        kubectl create secret generic kafka-credentials -n "${NAMESPACE}" \
                            --from-literal=bootstrap="${KAFKA_PASSWORDS_ARRAY[0]}" \
                            --from-literal=crypto="${KAFKA_PASSWORDS_ARRAY[1]}" \
                            --from-literal=db="${KAFKA_PASSWORDS_ARRAY[2]}" \
                            --from-literal=flow="${KAFKA_PASSWORDS_ARRAY[3]}" \
                            --from-literal=membership="${KAFKA_PASSWORDS_ARRAY[4]}" \
                            --from-literal=p2pGateway="${KAFKA_PASSWORDS_ARRAY[5]}" \
                            --from-literal=p2pLinkManager="${KAFKA_PASSWORDS_ARRAY[6]}" \
                            --from-literal=rpc="${KAFKA_PASSWORDS_ARRAY[7]}"
                    '''
                }
            }
            post {
                unsuccessful {
                    sh './support_bundle.sh ${NAMESPACE}'
                    archiveArtifacts artifacts: '*-support-bundle-*.tgz', allowEmptyArchive: true
                    sh 'rm -f *-support-bundle-*.tgz'
                }
            }
        }
        stage('Deploy clusters') {
           parallel {
               stage("Deploy Alice cluster") {
                  steps {
                      deployCorda("alice", "${NAMESPACE}", "${BASE_IMAGE}")
                  }
               }
               stage("Deploy Bob cluster") {
                  steps {
                      deployCorda("bob", "${NAMESPACE}", "${BASE_IMAGE}")
                  }
               }
               stage("Deploy Caroline cluster") {
                  steps {
                      deployCorda("caroline", "${NAMESPACE}", "${BASE_IMAGE}")
                  }
               }
           }
            post {
                unsuccessful {
                    sh './support_bundle.sh ${NAMESPACE}'
                    archiveArtifacts artifacts: '*-support-bundle-*.tgz', allowEmptyArchive: true
                    sh 'rm -f *-support-bundle-*.tgz'
                }
            }
        }
        stage('Forward port and run tests') {
            environment {
                E2E_CLUSTER_A_RPC_PASSWORD = "${getInitialAdminPassword('alice')}"
                E2E_CLUSTER_B_RPC_PASSWORD = "${getInitialAdminPassword('bob')}"
                E2E_CLUSTER_C_RPC_PASSWORD = "${getInitialAdminPassword('caroline')}"

                // Bob's cluster is used as a primary access point by Smoke and E2E tests
                INITIAL_ADMIN_USER_PASSWORD = "${E2E_CLUSTER_B_RPC_PASSWORD}"
            }
            options {
                timeout(time: 30, unit: 'MINUTES')
            }
            steps {
                script {
                    def workers = ['crypto-worker', 'rpc-worker', 'flow-worker','db-worker']
                    def clusters = ['alice','bob','caroline']

                    portForwarding("prereqs-kafka-0", 9092,9092)

                    clusters.eachWithIndex {c, index  ->
                       portForwarding("deployment/corda-$c-rpc-worker", 8887 + index, 8888)
                    }
                    workers.eachWithIndex {w, index  ->
                       portForwarding("deployment/corda-bob-$w", 7001 + index, 7000)
                    }
                }
                sh '''\
                    ./gradlew smokeTest ${GRADLE_PERFORMANCE_TUNING}
                    ./gradlew e2eTest ${GRADLE_PERFORMANCE_TUNING}
                '''.stripIndent()
            }
            post {
                always {
                    junit allowEmptyResults: true, testResults: '**/test-results/**/TEST-*.xml'
                    sh './support_bundle.sh ${NAMESPACE}'
                    archiveArtifacts artifacts: 'forward.txt, *-support-bundle-*.tgz', allowEmptyArchive: true
                    sh 'rm -f forward.txt *-support-bundle-*.tgz'
                }
            }
        }
    }
    post {
        always {
            findBuildScans()
            splunkLogGenerator()
            script{
                createSummary("yellow.png").appendText("<a href='https://r3ll3.splunkcloud.com/en-US/app/r3_kubernetes_app/namespace_details?form.namespace=${NAMESPACE}&form.cluster_name=eks-e2e&form.period.earliest=0&form.period.latest=&form.span=5m&form.pod=*&form.event_message=*'>Splunk K8s E2E Dashboard</a>", false)
                writeFile file: "e2eTestDataForSplunk.log", text: "${env.BUILD_URL}\n${NAMESPACE}"
                archiveArtifacts artifacts: "e2eTestDataForSplunk.log", fingerprint: true
                if (!params.KEEP_NS) {
                    sh 'kubectl delete ns "${NAMESPACE}"'
                }
            }
        }
    }
}

// K8s labels can not be greater than 63 characters
// Helper method to sanitize edge cases of very long branch names
def sanitizedBranchName(){
    return (env.BRANCH_NAME.length() > 60 ? env.BRANCH_NAME.substring(0,60).replace('/','-') : env.BRANCH_NAME.replace('/','-')).replaceFirst(/-+$/,'')
}

// Helper to expose ports prior to test execution
def portForwarding(def name, def port, def portMapping = null){
    sh "nohup .ci/e2eTests/utils/kubectl-port-forward-with-reconnect.sh ${NAMESPACE} $name $port $portMapping >> forward.txt 2>&1 &"
}

def deployCorda(def name, def namespace, def base_image){
    sh """
       helm install $name-db oci://corda-os-docker.software.r3.com/helm-charts/corda-dev \
           -f .ci/e2eTests/prereqs.yaml  -f .ci/e2eTests/prereqs-eks.yaml --set kafka.enabled=false \
           -n $namespace --wait --timeout 600s
       helm install corda-$name ./charts/corda \
           -f .ci/e2eTests/corda.yaml \
           -f .ci/e2eTests/corda-eks.yaml \
           --set image.tag=$base_image \
           --set nodeSelector.kubernetes\\\\.io/os=linux \
           --set nodeSelector.kubernetes\\\\.io/arch=${E2E_WORKER_ARCH} \
           --set nameOverride=$name \
           --set kafka.topicPrefix=$name \
           --set db.cluster.host=$name-db-postgresql \
           --set db.cluster.password.valueFrom.secretKeyRef.name=$name-db-postgresql \
           -n $namespace --wait --timeout 600s
    """.stripIndent()
}

def getBaseImage(def buildRev, def architectureTag) {
    return buildRev ? "preTest-${architectureTag}${buildRev}" : "${architectureTag}unstable"
}

def getInitialAdminPassword(def name) {
    def cmd = "kubectl get secret corda-${name}-initial-admin-user -n ${NAMESPACE} -o go-template='{{ .data.password | base64decode }}'"
    return sh(script: cmd, returnStdout: true)
}
