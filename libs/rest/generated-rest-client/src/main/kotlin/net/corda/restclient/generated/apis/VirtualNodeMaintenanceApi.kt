/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package net.corda.restclient.generated.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl


import com.fasterxml.jackson.annotation.JsonProperty

import net.corda.restclient.generated.infrastructure.ApiClient
import net.corda.restclient.generated.infrastructure.ApiResponse
import net.corda.restclient.generated.infrastructure.ClientException
import net.corda.restclient.generated.infrastructure.ClientError
import net.corda.restclient.generated.infrastructure.ServerException
import net.corda.restclient.generated.infrastructure.ServerError
import net.corda.restclient.generated.infrastructure.MultiValueMap
import net.corda.restclient.generated.infrastructure.PartConfig
import net.corda.restclient.generated.infrastructure.RequestConfig
import net.corda.restclient.generated.infrastructure.RequestMethod
import net.corda.restclient.generated.infrastructure.ResponseType
import net.corda.restclient.generated.infrastructure.Success
import net.corda.restclient.generated.infrastructure.toMultiValue

class VirtualNodeMaintenanceApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "/api/v5_3")
        }
    }

    /**
     * 
     * 
     * @return kotlin.Int
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMaintenanceVirtualnodeGetprotocolversion() : kotlin.Int {
        val localVarResponse = getMaintenanceVirtualnodeGetprotocolversionWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @return ApiResponse<kotlin.Int?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMaintenanceVirtualnodeGetprotocolversionWithHttpInfo() : ApiResponse<kotlin.Int?> {
        val localVariableConfig = getMaintenanceVirtualnodeGetprotocolversionRequestConfig()

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMaintenanceVirtualnodeGetprotocolversion
     *
     * @return RequestConfig
     */
    fun getMaintenanceVirtualnodeGetprotocolversionRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/maintenance/virtualnode/getprotocolversion",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Even if CPI with the same metadata has already been uploaded, this endpoint will overwrite the previously stored CPI record. This operation also purges any sandboxes running an overwritten version of a CPI. This action can take some time to process, therefore it is performed asynchronously.
     * @param upload A content of the file to upload. (optional)
     * @return net.corda.libs.cpiupload.endpoints.v1.CpiUploadRestResource.CpiUploadResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postMaintenanceVirtualnodeForcecpiupload(upload: java.io.File? = null) : net.corda.libs.cpiupload.endpoints.v1.CpiUploadRestResource.CpiUploadResponse {
        val localVarResponse = postMaintenanceVirtualnodeForcecpiuploadWithHttpInfo(upload = upload)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as net.corda.libs.cpiupload.endpoints.v1.CpiUploadRestResource.CpiUploadResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Even if CPI with the same metadata has already been uploaded, this endpoint will overwrite the previously stored CPI record. This operation also purges any sandboxes running an overwritten version of a CPI. This action can take some time to process, therefore it is performed asynchronously.
     * @param upload A content of the file to upload. (optional)
     * @return ApiResponse<net.corda.libs.cpiupload.endpoints.v1.CpiUploadRestResource.CpiUploadResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postMaintenanceVirtualnodeForcecpiuploadWithHttpInfo(upload: java.io.File?) : ApiResponse<net.corda.libs.cpiupload.endpoints.v1.CpiUploadRestResource.CpiUploadResponse?> {
        val localVariableConfig = postMaintenanceVirtualnodeForcecpiuploadRequestConfig(upload = upload)

        return request<Map<String, PartConfig<*>>, net.corda.libs.cpiupload.endpoints.v1.CpiUploadRestResource.CpiUploadResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postMaintenanceVirtualnodeForcecpiupload
     *
     * @param upload A content of the file to upload. (optional)
     * @return RequestConfig
     */
    fun postMaintenanceVirtualnodeForcecpiuploadRequestConfig(upload: java.io.File?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "upload" to PartConfig(body = upload, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/maintenance/virtualnode/forcecpiupload",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * Rollback the virtual node database for the given virtual node short ID. Then apply current CPI migrations. This operation is destructive and will result in user vault data being deleted, but will not have any effect on system tables.
     * @param virtualnodeshortid Short ID of the virtual node instance to rollback
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postMaintenanceVirtualnodeVirtualnodeshortidVaultSchemaForceResync(virtualnodeshortid: kotlin.String) : Unit {
        val localVarResponse = postMaintenanceVirtualnodeVirtualnodeshortidVaultSchemaForceResyncWithHttpInfo(virtualnodeshortid = virtualnodeshortid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * Rollback the virtual node database for the given virtual node short ID. Then apply current CPI migrations. This operation is destructive and will result in user vault data being deleted, but will not have any effect on system tables.
     * @param virtualnodeshortid Short ID of the virtual node instance to rollback
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postMaintenanceVirtualnodeVirtualnodeshortidVaultSchemaForceResyncWithHttpInfo(virtualnodeshortid: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = postMaintenanceVirtualnodeVirtualnodeshortidVaultSchemaForceResyncRequestConfig(virtualnodeshortid = virtualnodeshortid)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postMaintenanceVirtualnodeVirtualnodeshortidVaultSchemaForceResync
     *
     * @param virtualnodeshortid Short ID of the virtual node instance to rollback
     * @return RequestConfig
     */
    fun postMaintenanceVirtualnodeVirtualnodeshortidVaultSchemaForceResyncRequestConfig(virtualnodeshortid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.POST,
            path = "/maintenance/virtualnode/{virtualnodeshortid}/vault-schema/force-resync".replace("{"+"virtualnodeshortid"+"}", encodeURIComponent(virtualnodeshortid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
