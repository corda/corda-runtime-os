import java.nio.file.Files
import java.util.jar.JarFile

import groovy.transform.TupleConstructor
import javax.inject.Inject
import org.osgi.framework.Constants

plugins {
    id 'corda.common-library'
}

def applyDependencySubstitution = { Configuration conf ->
    conf.resolutionStrategy.dependencySubstitution {
        //Replace Kotlin stdlib
        substitute module('org.jetbrains.kotlin:kotlin-stdlib-jdk8') using module("net.corda.kotlin:kotlin-stdlib-jdk8-osgi:$kotlinVersion")
        substitute module('org.jetbrains.kotlin:kotlin-stdlib-jdk7') using module("net.corda.kotlin:kotlin-stdlib-jdk7-osgi:$kotlinVersion")
        substitute module('org.jetbrains.kotlin:kotlin-stdlib-common') using module("org.jetbrains.kotlin:kotlin-osgi-bundle:$kotlinVersion")
        substitute module('org.jetbrains.kotlin:kotlin-stdlib') using module("org.jetbrains.kotlin:kotlin-osgi-bundle:$kotlinVersion")
        substitute module('org.jetbrains.kotlin:kotlin-reflect') using module("org.jetbrains.kotlin:kotlin-osgi-bundle:$kotlinVersion")
    }
}

configurations {
    systemPackages {
        transitive = false
        canBeConsumed = false
    }
    bootstrapClasspath {
        transitive = true
        canBeConsumed = false
        extendsFrom(systemPackages)
        //This is to ensure that, when you add a project dependency to the configuration, you add the project's jar artifact,
        // otherwise Gradle adds the project's classes directory as that is usually enough to compile/run
        attributes { attrs ->
            attrs.attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements.class, LibraryElements.JAR))
        }
    }
    compileOnly {
        extendsFrom(systemPackages)
    }
    runtimeClasspath {
        //This is to ensure that, when you add a project dependency to the configuration, you add the project's jar artifact,
        // otherwise Gradle adds the project's classes directory as that is usually enough to compile/run
        attributes { attrs ->
            attrs.attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, objects.named(LibraryElements.class, LibraryElements.JAR))
        }
    }
    applyDependencySubstitution(systemPackages)
    applyDependencySubstitution(bootstrapClasspath)
    applyDependencySubstitution(runtimeClasspath)

    compileClassPath.shouldResolveConsistentlyWith(runtimeClasspath)
    systemPackages.shouldResolveConsistentlyWith(runtimeClasspath)
    bootstrapClasspath.shouldResolveConsistentlyWith(runtimeClasspath)
}

dependencies {
    bootstrapClasspath project(":osgi-framework-bootstrap")

    systemPackages "org.jboss.spec.javax.transaction:jboss-transaction-api_1.2_spec:$jbossTransactionApiSpecVersion"
    systemPackages "org.jetbrains.kotlin:kotlin-osgi-bundle:$kotlinVersion"
    systemPackages "net.corda.kotlin:kotlin-stdlib-jdk7-osgi:$kotlinVersion"
    systemPackages "net.corda.kotlin:kotlin-stdlib-jdk8-osgi:$kotlinVersion"
    systemPackages "org.slf4j:slf4j-api:$slf4jVersion"
    systemPackages "net.corda:corda-base:$cordaApiVersion"
    systemPackages project(":osgi-framework-api")
}

Provider<Jar> jarTask = tasks.named("jar", Jar)

private boolean isBundle(JarFile jarFile) {
    java.util.jar.Attributes mainAttributes = jarFile.manifest.mainAttributes
    return mainAttributes.getValue(Constants.BUNDLE_SYMBOLICNAME) != null && mainAttributes.getValue(Constants.BUNDLE_VERSION) != null
}

private static boolean isJar(final File file) {
    return file.name.endsWith(".jar")
}

private def addSystemPackagesExtra(
        final ArtifactCollection artifacts,
        final Set<String> systemBundleExtraSet
) {
    artifacts.each { resolvedArtifact ->
        final file = resolvedArtifact.file
        if (isJar(file)) {
            new JarFile(
                    resolvedArtifact.file,
                    true, JarFile.OPEN_READ,
                    JarFile.runtimeVersion()
            ).withCloseable { jarFile ->
                if (isBundle(jarFile)) {
                    jarFile.manifest.mainAttributes.getValue(org.osgi.framework.Constants.EXPORT_PACKAGE)?.with { exportPackage ->
                        aQute.bnd.header.OSGiHeader.parseHeader(exportPackage).entrySet().each { exportEntry ->
                            final def export = exportEntry.key + ";" + exportEntry.value.toString()
                            systemBundleExtraSet.add(export)
                            logger.info "OSGI $export included as system package extra."
                        }
                    }
                } else {
                    jarFile.versionedStream().filter { jarEntry ->
                        jarEntry.name.endsWith(".class")
                    }.each { jarEntry ->
                        String entryName = jarEntry.name
                        int end = entryName.lastIndexOf('/')
                        if (end > 0) {
                            final def export = entryName.substring(0, end).replace('/', '.')
                            systemBundleExtraSet.add(export)
                            logger.info "OSGI $export included as system package extra."
                        }
                    }
                }
            }
        }
    }
    final jdkExtraPackages = [
            "net.corda.osgi.framework.api",
            "sun.net.www.protocol.jar",
            "sun.nio.ch",
            "sun.security.x509",
            "sun.security.ssl",
            "javax.servlet",
            "javax.transaction;version=1.2.0",
            "javax.xml.stream;version=1.0",
            "javax.xml.stream.events;version=1.0",
            "javax.xml.stream.util;version=1.0"
    ]
    jdkExtraPackages.each { export -> systemBundleExtraSet.add(export) }
}

Provider<DefaultTask> createSystemBundlesFile = tasks.register("createSystemBundleFile") {
    inputs.files(jarTask)
    inputs.files(configurations.runtimeClasspath)
    File systemBundlesFile = new File(temporaryDir, "system_bundles")
    outputs.file(systemBundlesFile)
    doLast {
        systemBundlesFile.withWriter { writer ->
            writer.writeLine("bundles/${jarTask.flatMap {it.archiveFile }.map(RegularFile.&getAsFile).map(File.&getName).get()}")
            (configurations.runtimeClasspath - configurations.systemPackages).files.grep { File file -> isJar(file) && isBundle(new JarFile(file)) }.each { File file ->
                writer.writeLine("bundles/${file.name}")
            }
        }
    }
}

def cordaAssembleSystemPackagesExtraTask = tasks.register("createSystemPackagesExtraFile") {
    File systemPackagesExtraFile = new File(temporaryDir, "system_packages_extra")
    outputs.file(systemPackagesExtraFile)
    doLast {
        final Set<String> systemBundleExtraSet = new TreeSet<>()
        configurations.systemPackages.incoming.each { resolvableDependencies ->
            addSystemPackagesExtra(resolvableDependencies.artifacts as ArtifactCollection, systemBundleExtraSet)
        }
        systemPackagesExtraFile.withWriter { writer ->
            systemBundleExtraSet.each { export -> writer.writeLine(export) }
        }
    }
}


@TupleConstructor
class JavaAgent implements Serializable {
    String className
    String args
}

class OsgiRun {


    final List<JavaAgent> javaAgents = new ArrayList<JavaAgent>()
    final MapProperty<String, String> frameworkProperties

    @Inject
    OsgiRun(ObjectFactory objects) {
        frameworkProperties = objects.mapProperty(String.class, String.class).convention(new HashMap<>())
    }

    def agent(String className, String args) {
        javaAgents.add(new JavaAgent(className, args))
    }
}

OsgiRun osgiRun = extensions.create("osgiRun", OsgiRun.class)

def appJarBaseName = "corda-" + project.name

class FrameworkPropertyFile extends DefaultTask {

    @OutputFile
    File getOutputFile() {
        return new File(temporaryDir, "framework.properties")
    }

    @Input
    final MapProperty<String, String> frameworkProperties

    @Inject
    FrameworkPropertyFile(ObjectFactory objects) {
        frameworkProperties = objects.mapProperty(String.class, String.class)
    }

    @TaskAction
    void run() {
        Files.newBufferedWriter(getOutputFile().toPath()).withCloseable { Writer writer ->
            Properties properties = new Properties()
            frameworkProperties.get().forEach {key, value ->
                properties.put(key, value)
            }
            properties.store(writer, null)
        }
    }
}

Provider<FrameworkPropertyFile> writeFrameworkPropertyFile = tasks.register("writeFrameworkPropertyFile", FrameworkPropertyFile) {
    frameworkProperties = osgiRun.frameworkProperties
}

class JavaAgentFile extends DefaultTask {

    @OutputFile
    File getOutputFile() {
        return new File(temporaryDir, "javaAgents.properties")
    }

    @Input
    List<JavaAgent> javaAgents = new ArrayList<JavaAgent>()

    @TaskAction
    void run() {
        Files.newBufferedWriter(getOutputFile().toPath()).withCloseable { Writer writer ->
            Properties props = new Properties()
            javaAgents.each { JavaAgent javaAgent ->
                props.setProperty(javaAgent.className, javaAgent.args)
            }
            props.store(writer, null)
        }
    }
}

Provider<JavaAgentFile> javaAgentFileTask =  tasks.register("javaAgentFile", JavaAgentFile) {
    javaAgents = osgiRun.javaAgents
}

def appJar = tasks.register('appJar', Jar) {
    inputs.files(configurations.bootstrapClasspath)
    inputs.files(configurations.runtimeClasspath)
    inputs.files(configurations.systemPackages)
    inputs.files(jarTask)

    archivesBaseName = appJarBaseName
    destinationDirectory = layout.buildDirectory.dir("bin")

    exclude "META-INF/MANIFEST.MF"
    exclude "META-INF/*.SF"
    exclude "META-INF/*.DSA"
    exclude "META-INF/*.RSA"
    exclude "META-INF/*.EC"
    exclude "META-INF/DEPENDENCIES"
    exclude "META-INF/LICENSE"
    exclude "META-INF/NOTICE"
    exclude "module-info.class"
    exclude "META-INF/versions/*/module-info.class"
    duplicatesStrategy = DuplicatesStrategy.WARN
    manifest {
        attributes 'Main-Class': 'net.corda.osgi.framework.OSGiFrameworkMain'
        attributes 'Launcher-Agent-Class': 'net.corda.osgi.framework.JavaAgentLauncher'
        attributes 'Can-Redefine-Classes': true
        attributes 'Can-Retransform-Classes': true
    }

    into("META-INF/") {
        from(javaAgentFileTask)
    }
    from{ configurations.bootstrapClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    from(createSystemBundlesFile)
    from(cordaAssembleSystemPackagesExtraTask)
    from(writeFrameworkPropertyFile)
    into("bundles") {
        from(jarTask)
        from(configurations.runtimeClasspath - configurations.systemPackages) {
            eachFile { FileCopyDetails fileCopyDetails ->
                if(!isJar(new File(fileCopyDetails.sourcePath))) fileCopyDetails.exclude()
            }
        }
    }
}

artifacts {
    archives appJar
}

publishing {
    publications {
        mavenAppJar(MavenPublication) {
            artifactId appJarBaseName

            afterEvaluate {
                groupId project.group
                version project.version
                artifact appJar
            }
        }
    }
}
