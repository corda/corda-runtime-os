@Library('corda-shared-build-pipeline-steps@5.0') _

import groovy.transform.Field

@Field
String k8Namespace = "run-${UUID.randomUUID().toString()}"

pipeline {
    agent {
        docker {
            image 'build-zulu-openjdk:11'
            label 'docker'
            registryUrl 'https://engineering-docker.software.r3.com/'
            registryCredentialsId 'artifactory-credentials'
            // Volume used to mount storage from the host as a volume to persist the cache between builds
            // Additional hosts used to facilitate access to Kafka
            args '-v /tmp:/host_tmp'
            // make sure build image is always fresh
            alwaysPull true
        }
    }

    parameters {
        string(name: 'BUILD_REV', defaultValue: '', description: 'Short git hash of the build revision to test - leave blank to test unstable')
    }

    environment {
        ARTIFACTORY_CREDENTIALS = credentials('artifactory-credentials')
        BUILD_CACHE_CREDENTIALS = credentials('gradle-ent-cache-credentials')
        BUILD_CACHE_USERNAME = "${env.BUILD_CACHE_CREDENTIALS_USR}"
        BUILD_CACHE_PASSWORD = "${env.BUILD_CACHE_CREDENTIALS_PSW}"    
        CORDA_ARTIFACTORY_USERNAME = "${env.ARTIFACTORY_CREDENTIALS_USR}"
        CORDA_ARTIFACTORY_PASSWORD = "${env.ARTIFACTORY_CREDENTIALS_PSW}"
        CORDA_USE_CACHE = "corda-remotes"
        KUBECONFIG = credentials("e2e-tests-credentials")
        CORDA_CLI_USER_HOME = "/tmp/corda-cli-home"
        CORDA_GRADLE_SCAN_KEY = credentials('gradle-build-scans-key')
        GRADLE_USER_HOME = "/host_tmp/gradle"
        CORDA_REVISION = "${env.GIT_COMMIT}"
        NAMESPACE = "$k8Namespace"
        CLUSTER_NAME = "eks-e2e.e2e.awsdev.r3.com"
        HELM_CONFIG_HOME = "/tmp/helm"
        HELM_REPOSITORY_CACHE = "/host_tmp/helm/repository"
        GRADLE_PERFORMANCE_TUNING = "--parallel -Dscan.tag.E2E -Dscan.tag.${env.NAMESPACE} --build-cache"
        E2E_CLUSTER_A_RPC_PORT=8887
        E2E_CLUSTER_B_RPC_PORT=8888
        E2E_CLUSTER_C_RPC_PORT=8889
        E2E_CLUSTER_A_P2P_HOST="corda-alice-p2p-gateway-worker.${NAMESPACE}.svc.cluster.local"
        E2E_CLUSTER_B_P2P_HOST="corda-bob-p2p-gateway-worker.${NAMESPACE}.svc.cluster.local"
        E2E_CLUSTER_C_P2P_HOST="corda-caroline-p2p-gateway-worker.${NAMESPACE}.svc.cluster.local"
    }

    options {
        buildDiscarder(logRotator(daysToKeepStr: '14', artifactDaysToKeepStr: '14'))
        timeout(time: 30, unit: 'MINUTES')
        timestamps()
    }

    stages {
        stage ('Create namespace') {
            steps {
                sh """
                    kubectl create ns $NAMESPACE
                    kubectl label ns $NAMESPACE namespace-type=corda-e2e --overwrite=true
                    kubectl label ns $NAMESPACE branch=${sanitizedBranchName()} --overwrite=true
                """
            }
        }
        stage('Install kafka as prereqs') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'artifactory-credentials', passwordVariable: 'PASSWORD', usernameVariable: 'USER')]) {
                    sh '''
                        helm repo add bitnami https://charts.bitnami.com/bitnami
                        echo $PASSWORD | helm registry login corda-os-docker.software.r3.com -u $USER --password-stdin
                        helm install prereqs bitnami/kafka -f ./.ci/e2eTests/kafka.yaml -n $NAMESPACE --wait --timeout 600s
                    '''
                }
            }
            post {
                always {
                    sh '''
                        kubectl logs -lapp.kubernetes.io/instance=prereqs -n ${NAMESPACE} --all-containers=true --prefix=true --tail=-1 > prereqsLogs.txt
                        kubectl describe all -n ${NAMESPACE} > prereqsDescribe.txt
                    '''
                    archiveArtifacts artifacts: 'prereqsLogs.txt, prereqsDescribe.txt', allowEmptyArchive: true
                    sh 'rm -f prereqsLogs.txt prereqsDescribe.txt'
                }
            }
        }
        stage('Deploy clusters') {
           parallel {
               stage("Deploy Alice cluster") {
                  steps {
                      script {
                         env.BASE_IMAGE = params.BUILD_REV ? "preTest-${params.BUILD_REV}" : "unstable"
                      }
                      sh '''
                            helm install alice-db bitnami/postgresql -f ./.ci/e2eTests/postgres.yaml -n $NAMESPACE --wait --timeout 600s
                            export SASL_SECRET=$(kubectl get secret -n $NAMESPACE prereqs-kafka-jaas -o=jsonpath='{.data.client-passwords}' | base64 --decode)
                            helm install corda-alice ./charts/corda -f .ci/e2eTests/corda.yaml --set kafka.sasl.password=$SASL_SECRET --set image.tag=$BASE_IMAGE --set nameOverride=alice --set kafka.topicPrefix=alice --set db.cluster.host=alice-db-postgresql --set db.cluster.existingSecret=alice-db-postgresql -n $NAMESPACE --wait --timeout 600s
                        '''
                  }
               }
               stage("Deploy Bob cluster") {
                  steps {
                      script {
                         env.BASE_IMAGE = params.BUILD_REV ? "preTest-${params.BUILD_REV}" : "unstable"
                      }
                      sh '''
                            helm install bob-db bitnami/postgresql -f ./.ci/e2eTests/postgres.yaml -n $NAMESPACE --wait --timeout 600s
                            export SASL_SECRET=$(kubectl get secret -n $NAMESPACE prereqs-kafka-jaas -o=jsonpath='{.data.client-passwords}' | base64 --decode)
                            helm install corda-bob ./charts/corda -f .ci/e2eTests/corda.yaml --set kafka.sasl.password=$SASL_SECRET --set image.tag=$BASE_IMAGE --set nameOverride=bob --set kafka.topicPrefix=bob --set db.cluster.host=bob-db-postgresql --set db.cluster.existingSecret=bob-db-postgresql -n $NAMESPACE --wait --timeout 600s
                        '''
                  }
               }
               stage("Deploy Caroline cluster") {
                  steps {
                      script {
                         env.BASE_IMAGE = params.BUILD_REV ? "preTest-${params.BUILD_REV}" : "unstable"
                      }
                      sh '''
                            helm install caroline-db bitnami/postgresql -f ./.ci/e2eTests/postgres.yaml -n $NAMESPACE --wait --timeout 600s
                            export SASL_SECRET=$(kubectl get secret -n $NAMESPACE prereqs-kafka-jaas -o=jsonpath='{.data.client-passwords}' | base64 --decode)
                            helm install corda-caroline ./charts/corda -f .ci/e2eTests/corda.yaml --set kafka.sasl.password=$SASL_SECRET --set image.tag=$BASE_IMAGE --set nameOverride=caroline --set kafka.topicPrefix=caroline --set db.cluster.host=caroline-db-postgresql --set db.cluster.existingSecret=caroline-db-postgresql -n $NAMESPACE --wait --timeout 600s
                        '''
                  }
               }
           }
            post {
                unsuccessful {
                    sh '''
                        kubectl logs -lapp.kubernetes.io/instance=corda-alice -n ${NAMESPACE} --all-containers=true --prefix=true --tail=-1 > logs.txt
                        kubectl logs -lapp.kubernetes.io/instance=corda-bob -n ${NAMESPACE} --all-containers=true --prefix=true --tail=-1 >> logs.txt
                        kubectl logs -lapp.kubernetes.io/instance=corda-caroline -n ${NAMESPACE} --all-containers=true --prefix=true --tail=-1 >> logs.txt
                        kubectl describe all -n ${NAMESPACE} > describe.txt
                    '''
                    archiveArtifacts artifacts: 'logs.txt, describe.txt', allowEmptyArchive: true
                    sh 'rm -f logs.txt describe.txt'
                }
            }
        }
        stage('Forward port and run tests') {
            steps {
                script {
                    def workers = ['crypto-worker', 'rpc-worker', 'flow-worker','db-worker']
                    def clusters = ['alice','bob','caroline'] // parameratize fuck you

                    portForwarding("prereqs-kafka-0", 9092)

                    clusters.eachWithIndex {c, index  ->
                       portForwarding("deploy/corda-$c-rpc-worker", 8886 + index+1, 8888)
                    }
                    workers.eachWithIndex {w, index  ->
                       portForwarding("deploy/corda-alice-$w", 7001 + index+1, 7000)
                    }
                }

                sh "./gradlew cleanE2eTest smokeTest e2eTest ${GRADLE_PERFORMANCE_TUNING}"
            }
            post {
                always {
                    junit allowEmptyResults: true, testResults: '**/test-results/**/TEST-*.xml'
                    sh '''
                        kubectl logs -lapp.kubernetes.io/instance=corda -n ${NAMESPACE} --all-containers=true --prefix=true --tail=-1 > logs.txt
                        kubectl describe all -n ${NAMESPACE} > describe.txt
                        pgrep nohup | xargs kill -9
                    '''
                    archiveArtifacts artifacts: 'forward.txt, logs.txt, describe.txt', allowEmptyArchive: true
                    sh 'rm -f forward.txt logs.txt describe.txt'
                }
            }
        }
    }
    post {
        always {
            findBuildScans()
            splunkLogGenerator()
            script{
                createSummary("yellow.png").appendText("<a href='https://r3ll3.splunkcloud.com/en-US/app/r3_kubernetes_app/kubernetes_overview?form.period.earliest=0&form.period.latest=&form.span=5m&form.cluster=eks-e2e&form.namespace=${NAMESPACE}&form.pod=*'>Splunk K8s E2E Dashboard</a>", false)
                writeFile file: "e2eTestDataForSplunk.log", text: "${env.BUILD_URL}\n${NAMESPACE}"
                archiveArtifacts artifacts: "e2eTestDataForSplunk.log", fingerprint: true
            }
        }
        success {
            // Only delete namespace if we're successful (though it'll get pruned in 3 hours anyway)
            sh 'kubectl delete ns "${NAMESPACE}"'
        }
    }
}

// K8s labels can not be greater than 63 characters 
// Helper method to sanitize edge cases of very long branch names
def sanitizedBranchName(){
    return env.BRANCH_NAME.length() > 60 ? env.BRANCH_NAME.substring(0,60).replace('/','-') : env.BRANCH_NAME.replace('/','-')
}

// Helper to expose ports prior to test execution
def portForwarding(def name, def port, def portMapping){
    if(name.contains('prereqs-kafka')) {
        sh "nohup kubectl port-forward -n ${NAMESPACE} $name $port > forward.txt 2>&1 &"
    } else {
        sh "nohup kubectl port-forward -n ${NAMESPACE} $name $port:$portMapping >> forward.txt 2>&1 &"
    }
}
