package net.corda.cipher.suite.internal

import net.corda.crypto.BasicCryptoPersistentKey
import net.corda.crypto.internal.BasicCachedKey
import net.corda.crypto.internal.BasicKeyCacheImpl
import net.corda.impl.test.MockDatabaseBuilder
import net.corda.crypto.internal.SimplePersistentCacheFactory
import net.corda.crypto.internal.SimplePersistentCacheImpl
import net.corda.crypto.testkit.CryptoMocks
import net.corda.v5.cipher.suite.CipherSchemeMetadata
import net.corda.v5.cipher.suite.scheme.EDDSA_ED25519_CODE_NAME
import net.corda.v5.crypto.SignatureVerificationService
import net.corda.v5.cipher.suite.WrappedPrivateKey
import net.corda.v5.cipher.suite.scheme.KeyScheme
import org.hibernate.SessionFactory
import org.junit.jupiter.api.AfterAll
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Timeout
import java.security.SignatureException
import java.util.*
import kotlin.test.assertFailsWith
import kotlin.test.assertNotEquals

class DefaultCryptoServicePartitionedTests {
    companion object {
        const val wrappingKeyAlias = "wrapping-key-alias"
        lateinit var sessionFactory: SessionFactory
        lateinit var cache: SimplePersistentCacheImpl<BasicCachedKey, BasicCryptoPersistentKey>
        lateinit var defaultCryptoServicePartition1: DefaultCryptoService
        lateinit var defaultCryptoServicePartition2: DefaultCryptoService
        lateinit var signatureVerifier: SignatureVerificationService
        lateinit var defaultKeyScheme: KeyScheme
        lateinit var schemeMetadata: CipherSchemeMetadata

        @JvmStatic
        @BeforeAll
        fun setup() {
            val cryptoMocks = CryptoMocks()
            sessionFactory = MockDatabaseBuilder.resetDatabase()
            cache = SimplePersistentCacheImpl(
                    BasicCryptoPersistentKey::class.java,
                    sessionFactory
            )
            schemeMetadata = cryptoMocks.schemeMetadata()
            defaultKeyScheme = schemeMetadata.findKeyScheme(EDDSA_ED25519_CODE_NAME)
            defaultCryptoServicePartition1 = DefaultCryptoService(
                    BasicKeyCacheImpl(
                            sandboxId = "",
                            partition = "p111",
                            passphrase = "passphrase-111",
                            salt = "11",
                            cacheFactory = object : SimplePersistentCacheFactory<BasicCachedKey, BasicCryptoPersistentKey> {
                                override fun create() = cache
                            },
                            schemeMetadata = schemeMetadata
                    ),
                    schemeMetadata = schemeMetadata
            )
            defaultCryptoServicePartition2 = DefaultCryptoService(
                    BasicKeyCacheImpl(
                            sandboxId = "",
                            partition = "p222",
                            passphrase = "passphrase-222",
                            salt = "22",
                            cacheFactory = object : SimplePersistentCacheFactory<BasicCachedKey, BasicCryptoPersistentKey> {
                                override fun create() = cache
                            },
                            schemeMetadata = schemeMetadata
                    ),
                    schemeMetadata = schemeMetadata
            )
            signatureVerifier = CryptoMocks().signatureVerificationService()
            defaultCryptoServicePartition1.createWrappingKey(wrappingKeyAlias, true)
            defaultCryptoServicePartition2.createWrappingKey(wrappingKeyAlias, true)
        }

        @JvmStatic
        @AfterAll
        fun cleanup() {
            sessionFactory.close()
        }
    }

    private val testData = "test data".toByteArray()

    @Test
    @Timeout(30)
    fun `Test wrapped keys are not affected by partitioning and usable`() {
        val wrappedKeyPair1 = defaultCryptoServicePartition1.generateWrappedKeyPair(wrappingKeyAlias, defaultKeyScheme)
        val wrappedKeyPair2 = defaultCryptoServicePartition2.generateWrappedKeyPair(wrappingKeyAlias, defaultKeyScheme)
        val signature1 = defaultCryptoServicePartition1.sign(
                WrappedPrivateKey(
                        keyMaterial = wrappedKeyPair1.keyMaterial,
                        masterKeyAlias = wrappingKeyAlias,
                        keyScheme = defaultKeyScheme,
                        encodingVersion = wrappedKeyPair1.encodingVersion
                ),
                testData
        )
        val signature2 = defaultCryptoServicePartition2.sign(
                WrappedPrivateKey(
                        keyMaterial = wrappedKeyPair2.keyMaterial,
                        masterKeyAlias = wrappingKeyAlias,
                        keyScheme = defaultKeyScheme,
                        encodingVersion = wrappedKeyPair2.encodingVersion
                ),
                testData
        )
        signatureVerifier.verify(wrappedKeyPair1.publicKey, signature1, testData)
        signatureVerifier.verify(wrappedKeyPair2.publicKey, signature2, testData)
        assertFailsWith<SignatureException> {
            signatureVerifier.verify(wrappedKeyPair1.publicKey, signature2, testData)
        }
        assertFailsWith<SignatureException> {
            signatureVerifier.verify(wrappedKeyPair2.publicKey, signature1, testData)
        }
    }

    @Test
    @Timeout(30)
    fun `Test keys are partitioned and usable`() {
        val alias = newAlias()
        val publicKey1 = defaultCryptoServicePartition1.generateKeyPair(alias, defaultKeyScheme)
        val publicKey2 = defaultCryptoServicePartition2.generateKeyPair(alias, defaultKeyScheme)
        assertNotEquals(publicKey1, publicKey2)
        val signature1 = defaultCryptoServicePartition1.sign(alias, testData, defaultKeyScheme)
        val signature2 = defaultCryptoServicePartition2.sign(alias, testData, defaultKeyScheme)
        signatureVerifier.verify(publicKey1, signature1, testData)
        signatureVerifier.verify(publicKey2, signature2, testData)
        assertFailsWith<SignatureException> {
            signatureVerifier.verify(publicKey1, signature2, testData)
        }
        assertFailsWith<SignatureException> {
            signatureVerifier.verify(publicKey2, signature1, testData)
        }
    }

    private fun newAlias(): String = UUID.randomUUID().toString()
}
