/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package net.corda.restclient.generated.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl


import com.fasterxml.jackson.annotation.JsonProperty

import net.corda.restclient.generated.infrastructure.ApiClient
import net.corda.restclient.generated.infrastructure.ApiResponse
import net.corda.restclient.generated.infrastructure.ClientException
import net.corda.restclient.generated.infrastructure.ClientError
import net.corda.restclient.generated.infrastructure.ServerException
import net.corda.restclient.generated.infrastructure.ServerError
import net.corda.restclient.generated.infrastructure.MultiValueMap
import net.corda.restclient.generated.infrastructure.PartConfig
import net.corda.restclient.generated.infrastructure.RequestConfig
import net.corda.restclient.generated.infrastructure.RequestMethod
import net.corda.restclient.generated.infrastructure.ResponseType
import net.corda.restclient.generated.infrastructure.Success
import net.corda.restclient.generated.infrastructure.toMultiValue

class KeyManagementApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "/api/v5_3")
        }
    }

    /**
     * 
     * 
     * @return kotlin.Int
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getKeyGetprotocolversion() : kotlin.Int {
        val localVarResponse = getKeyGetprotocolversionWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Int
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @return ApiResponse<kotlin.Int?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getKeyGetprotocolversionWithHttpInfo() : ApiResponse<kotlin.Int?> {
        val localVariableConfig = getKeyGetprotocolversionRequestConfig()

        return request<Unit, kotlin.Int>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getKeyGetprotocolversion
     *
     * @return RequestConfig
     */
    fun getKeyGetprotocolversionRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/key/getprotocolversion",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This method retrieves information about a list of key pairs belonging to a tenant.
     * @param tenantid Can either be a holding identity ID, the value &#39;p2p&#39; for a cluster-level tenant of the P2P services, or the value &#39;rest&#39; for a cluster-level tenant of the REST
     * @param skip The response paging information, number of records to skip (optional)
     * @param take The response paging information, that is, the number of records to return. The actual number returned may be less than requested. (optional)
     * @param orderby Specifies how to order the results. Can be one of &#39;NONE&#39;, &#39;TIMESTAMP&#39;, &#39;CATEGORY&#39;, &#39;SCHEME_CODE_NAME&#39;, &#39;ALIAS&#39;, &#39;MASTER_KEY_ALIAS&#39;, &#39;EXTERNAL_ID&#39;, &#39;ID&#39;, &#39;TIMESTAMP_DESC&#39;, &#39;CATEGORY_DESC&#39;, &#39;SCHEME_CODE_NAME_DESC&#39;, &#39;ALIAS_DESC&#39;, &#39;MASTER_KEY_ALIAS_DESC&#39;, &#39;EXTERNAL_ID_DESC&#39;, &#39;ID_DESC&#39;. (optional)
     * @param category Category of the HSM which handles the key pairs. Can be one of &#39;ACCOUNTS&#39;, &#39;CI&#39;, &#39;LEDGER&#39;, &#39;NOTARY&#39;, &#39;SESSION_INIT&#39;, &#39;TLS&#39;, &#39;JWT_KEY&#39;. (optional)
     * @param schemecodename The key pairs&#39; signature scheme name. For example, &#39;CORDA.RSA&#39;, &#39;CORDA.ECDSA.SECP256K1&#39;, &#39;CORDA.ECDSA.SECP256R1&#39;, &#39;CORDA.EDDSA.ED25519&#39;, &#39;CORDA.SPHINCS-256&#39;. (optional)
     * @param alias The alias under which the key pair is stored (optional)
     * @param masterkeyalias The alias of the wrapping key (optional)
     * @param createdafter Only include key pairs which were created on or after the specified time. Must be a valid instant in UTC, such as 2022-12-03T10:15:30.00Z. (optional)
     * @param createdbefore Only include key pairs which were created on or before the specified time. Must be a valid instant in UTC, such as 2022-12-03T10:15:30.00Z. (optional)
     * @param id Only include key pairs associated with the specified list of key IDs. If specified, other filter parameters will be ignored. (optional)
     * @return kotlin.collections.Map<kotlin.String, net.corda.membership.rest.v1.types.response.KeyMetaData>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getKeyTenantid(tenantid: kotlin.String, skip: kotlin.Int? = null, take: kotlin.Int? = null, orderby: kotlin.String? = null, category: kotlin.String? = null, schemecodename: kotlin.String? = null, alias: kotlin.String? = null, masterkeyalias: kotlin.String? = null, createdafter: kotlin.String? = null, createdbefore: kotlin.String? = null, id: kotlin.collections.List<kotlin.String>? = null) : kotlin.collections.Map<kotlin.String, net.corda.membership.rest.v1.types.response.KeyMetaData> {
        val localVarResponse = getKeyTenantidWithHttpInfo(tenantid = tenantid, skip = skip, take = take, orderby = orderby, category = category, schemecodename = schemecodename, alias = alias, masterkeyalias = masterkeyalias, createdafter = createdafter, createdbefore = createdbefore, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, net.corda.membership.rest.v1.types.response.KeyMetaData>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This method retrieves information about a list of key pairs belonging to a tenant.
     * @param tenantid Can either be a holding identity ID, the value &#39;p2p&#39; for a cluster-level tenant of the P2P services, or the value &#39;rest&#39; for a cluster-level tenant of the REST
     * @param skip The response paging information, number of records to skip (optional)
     * @param take The response paging information, that is, the number of records to return. The actual number returned may be less than requested. (optional)
     * @param orderby Specifies how to order the results. Can be one of &#39;NONE&#39;, &#39;TIMESTAMP&#39;, &#39;CATEGORY&#39;, &#39;SCHEME_CODE_NAME&#39;, &#39;ALIAS&#39;, &#39;MASTER_KEY_ALIAS&#39;, &#39;EXTERNAL_ID&#39;, &#39;ID&#39;, &#39;TIMESTAMP_DESC&#39;, &#39;CATEGORY_DESC&#39;, &#39;SCHEME_CODE_NAME_DESC&#39;, &#39;ALIAS_DESC&#39;, &#39;MASTER_KEY_ALIAS_DESC&#39;, &#39;EXTERNAL_ID_DESC&#39;, &#39;ID_DESC&#39;. (optional)
     * @param category Category of the HSM which handles the key pairs. Can be one of &#39;ACCOUNTS&#39;, &#39;CI&#39;, &#39;LEDGER&#39;, &#39;NOTARY&#39;, &#39;SESSION_INIT&#39;, &#39;TLS&#39;, &#39;JWT_KEY&#39;. (optional)
     * @param schemecodename The key pairs&#39; signature scheme name. For example, &#39;CORDA.RSA&#39;, &#39;CORDA.ECDSA.SECP256K1&#39;, &#39;CORDA.ECDSA.SECP256R1&#39;, &#39;CORDA.EDDSA.ED25519&#39;, &#39;CORDA.SPHINCS-256&#39;. (optional)
     * @param alias The alias under which the key pair is stored (optional)
     * @param masterkeyalias The alias of the wrapping key (optional)
     * @param createdafter Only include key pairs which were created on or after the specified time. Must be a valid instant in UTC, such as 2022-12-03T10:15:30.00Z. (optional)
     * @param createdbefore Only include key pairs which were created on or before the specified time. Must be a valid instant in UTC, such as 2022-12-03T10:15:30.00Z. (optional)
     * @param id Only include key pairs associated with the specified list of key IDs. If specified, other filter parameters will be ignored. (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, net.corda.membership.rest.v1.types.response.KeyMetaData>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getKeyTenantidWithHttpInfo(tenantid: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, orderby: kotlin.String?, category: kotlin.String?, schemecodename: kotlin.String?, alias: kotlin.String?, masterkeyalias: kotlin.String?, createdafter: kotlin.String?, createdbefore: kotlin.String?, id: kotlin.collections.List<kotlin.String>?) : ApiResponse<kotlin.collections.Map<kotlin.String, net.corda.membership.rest.v1.types.response.KeyMetaData>?> {
        val localVariableConfig = getKeyTenantidRequestConfig(tenantid = tenantid, skip = skip, take = take, orderby = orderby, category = category, schemecodename = schemecodename, alias = alias, masterkeyalias = masterkeyalias, createdafter = createdafter, createdbefore = createdbefore, id = id)

        return request<Unit, kotlin.collections.Map<kotlin.String, net.corda.membership.rest.v1.types.response.KeyMetaData>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getKeyTenantid
     *
     * @param tenantid Can either be a holding identity ID, the value &#39;p2p&#39; for a cluster-level tenant of the P2P services, or the value &#39;rest&#39; for a cluster-level tenant of the REST
     * @param skip The response paging information, number of records to skip (optional)
     * @param take The response paging information, that is, the number of records to return. The actual number returned may be less than requested. (optional)
     * @param orderby Specifies how to order the results. Can be one of &#39;NONE&#39;, &#39;TIMESTAMP&#39;, &#39;CATEGORY&#39;, &#39;SCHEME_CODE_NAME&#39;, &#39;ALIAS&#39;, &#39;MASTER_KEY_ALIAS&#39;, &#39;EXTERNAL_ID&#39;, &#39;ID&#39;, &#39;TIMESTAMP_DESC&#39;, &#39;CATEGORY_DESC&#39;, &#39;SCHEME_CODE_NAME_DESC&#39;, &#39;ALIAS_DESC&#39;, &#39;MASTER_KEY_ALIAS_DESC&#39;, &#39;EXTERNAL_ID_DESC&#39;, &#39;ID_DESC&#39;. (optional)
     * @param category Category of the HSM which handles the key pairs. Can be one of &#39;ACCOUNTS&#39;, &#39;CI&#39;, &#39;LEDGER&#39;, &#39;NOTARY&#39;, &#39;SESSION_INIT&#39;, &#39;TLS&#39;, &#39;JWT_KEY&#39;. (optional)
     * @param schemecodename The key pairs&#39; signature scheme name. For example, &#39;CORDA.RSA&#39;, &#39;CORDA.ECDSA.SECP256K1&#39;, &#39;CORDA.ECDSA.SECP256R1&#39;, &#39;CORDA.EDDSA.ED25519&#39;, &#39;CORDA.SPHINCS-256&#39;. (optional)
     * @param alias The alias under which the key pair is stored (optional)
     * @param masterkeyalias The alias of the wrapping key (optional)
     * @param createdafter Only include key pairs which were created on or after the specified time. Must be a valid instant in UTC, such as 2022-12-03T10:15:30.00Z. (optional)
     * @param createdbefore Only include key pairs which were created on or before the specified time. Must be a valid instant in UTC, such as 2022-12-03T10:15:30.00Z. (optional)
     * @param id Only include key pairs associated with the specified list of key IDs. If specified, other filter parameters will be ignored. (optional)
     * @return RequestConfig
     */
    fun getKeyTenantidRequestConfig(tenantid: kotlin.String, skip: kotlin.Int?, take: kotlin.Int?, orderby: kotlin.String?, category: kotlin.String?, schemecodename: kotlin.String?, alias: kotlin.String?, masterkeyalias: kotlin.String?, createdafter: kotlin.String?, createdbefore: kotlin.String?, id: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (skip != null) {
                    put("skip", listOf(skip.toString()))
                }
                if (take != null) {
                    put("take", listOf(take.toString()))
                }
                if (orderby != null) {
                    put("orderby", listOf(orderby.toString()))
                }
                if (category != null) {
                    put("category", listOf(category.toString()))
                }
                if (schemecodename != null) {
                    put("schemecodename", listOf(schemecodename.toString()))
                }
                if (alias != null) {
                    put("alias", listOf(alias.toString()))
                }
                if (masterkeyalias != null) {
                    put("masterkeyalias", listOf(masterkeyalias.toString()))
                }
                if (createdafter != null) {
                    put("createdafter", listOf(createdafter.toString()))
                }
                if (createdbefore != null) {
                    put("createdbefore", listOf(createdbefore.toString()))
                }
                if (id != null) {
                    put("id", toMultiValue(id.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/key/{tenantid}".replace("{"+"tenantid"+"}", encodeURIComponent(tenantid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This method retrieves a tenant&#39;s public key in PEM format.
     * @param tenantid Can either be a holding identity ID, the value &#39;p2p&#39; for a cluster-level tenant of the P2P services, or the value &#39;rest&#39; for a cluster-level tenant of the REST
     * @param keyid Identifier of the public key to be retrieved
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getKeyTenantidKeyid(tenantid: kotlin.String, keyid: kotlin.String) : kotlin.String {
        val localVarResponse = getKeyTenantidKeyidWithHttpInfo(tenantid = tenantid, keyid = keyid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This method retrieves a tenant&#39;s public key in PEM format.
     * @param tenantid Can either be a holding identity ID, the value &#39;p2p&#39; for a cluster-level tenant of the P2P services, or the value &#39;rest&#39; for a cluster-level tenant of the REST
     * @param keyid Identifier of the public key to be retrieved
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getKeyTenantidKeyidWithHttpInfo(tenantid: kotlin.String, keyid: kotlin.String) : ApiResponse<kotlin.String?> {
        val localVariableConfig = getKeyTenantidKeyidRequestConfig(tenantid = tenantid, keyid = keyid)

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getKeyTenantidKeyid
     *
     * @param tenantid Can either be a holding identity ID, the value &#39;p2p&#39; for a cluster-level tenant of the P2P services, or the value &#39;rest&#39; for a cluster-level tenant of the REST
     * @param keyid Identifier of the public key to be retrieved
     * @return RequestConfig
     */
    fun getKeyTenantidKeyidRequestConfig(tenantid: kotlin.String, keyid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/key/{tenantid}/{keyid}".replace("{"+"tenantid"+"}", encodeURIComponent(tenantid.toString())).replace("{"+"keyid"+"}", encodeURIComponent(keyid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This method retrieves a list of supported key schemes for a specified tenant and HSM category.
     * @param tenantid Can either be a holding identity ID, the value &#39;p2p&#39; for a cluster-level tenant of the P2P services, or the value &#39;rest&#39; for a cluster-level tenant of the REST
     * @param hsmcategory The category of the HSM. Can be the value &#39;ACCOUNTS&#39;, &#39;CI&#39;, &#39;LEDGER&#39;, &#39;NOTARY&#39;, &#39;SESSION_INIT&#39;, &#39;TLS&#39;, or &#39;JWT_KEY&#39;
     * @return kotlin.collections.List<kotlin.String>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getKeyTenantidSchemesHsmcategory(tenantid: kotlin.String, hsmcategory: kotlin.String) : kotlin.collections.List<kotlin.String> {
        val localVarResponse = getKeyTenantidSchemesHsmcategoryWithHttpInfo(tenantid = tenantid, hsmcategory = hsmcategory)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.String>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This method retrieves a list of supported key schemes for a specified tenant and HSM category.
     * @param tenantid Can either be a holding identity ID, the value &#39;p2p&#39; for a cluster-level tenant of the P2P services, or the value &#39;rest&#39; for a cluster-level tenant of the REST
     * @param hsmcategory The category of the HSM. Can be the value &#39;ACCOUNTS&#39;, &#39;CI&#39;, &#39;LEDGER&#39;, &#39;NOTARY&#39;, &#39;SESSION_INIT&#39;, &#39;TLS&#39;, or &#39;JWT_KEY&#39;
     * @return ApiResponse<kotlin.collections.List<kotlin.String>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getKeyTenantidSchemesHsmcategoryWithHttpInfo(tenantid: kotlin.String, hsmcategory: kotlin.String) : ApiResponse<kotlin.collections.List<kotlin.String>?> {
        val localVariableConfig = getKeyTenantidSchemesHsmcategoryRequestConfig(tenantid = tenantid, hsmcategory = hsmcategory)

        return request<Unit, kotlin.collections.List<kotlin.String>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getKeyTenantidSchemesHsmcategory
     *
     * @param tenantid Can either be a holding identity ID, the value &#39;p2p&#39; for a cluster-level tenant of the P2P services, or the value &#39;rest&#39; for a cluster-level tenant of the REST
     * @param hsmcategory The category of the HSM. Can be the value &#39;ACCOUNTS&#39;, &#39;CI&#39;, &#39;LEDGER&#39;, &#39;NOTARY&#39;, &#39;SESSION_INIT&#39;, &#39;TLS&#39;, or &#39;JWT_KEY&#39;
     * @return RequestConfig
     */
    fun getKeyTenantidSchemesHsmcategoryRequestConfig(tenantid: kotlin.String, hsmcategory: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/key/{tenantid}/schemes/{hsmcategory}".replace("{"+"tenantid"+"}", encodeURIComponent(tenantid.toString())).replace("{"+"hsmcategory"+"}", encodeURIComponent(hsmcategory.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * This method generates a new key pair for a tenant.
     * @param tenantid Can either be a holding identity ID, the value &#39;p2p&#39; for a cluster-level tenant of the P2P services, or the value &#39;rest&#39; for a cluster-level tenant of the REST
     * @param alias The alias under which the new key pair will be stored
     * @param hsmcategory Category of the HSM which handles the key pairs. Can be one of &#39;ACCOUNTS&#39;, &#39;CI&#39;, &#39;LEDGER&#39;, &#39;NOTARY&#39;, &#39;SESSION_INIT&#39;, &#39;TLS&#39;, &#39;JWT_KEY&#39;.
     * @param scheme The key&#39;s scheme describing which type of the key pair to generate. For example, &#39;CORDA.RSA&#39;, &#39;CORDA.ECDSA.SECP256K1&#39;, &#39;CORDA.ECDSA.SECP256R1&#39;, &#39;CORDA.EDDSA.ED25519&#39;, &#39;CORDA.SPHINCS-256&#39;.
     * @return net.corda.membership.rest.v1.types.response.KeyPairIdentifier
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postKeyTenantidAliasAliasCategoryHsmcategorySchemeScheme(tenantid: kotlin.String, alias: kotlin.String, hsmcategory: kotlin.String, scheme: kotlin.String) : net.corda.membership.rest.v1.types.response.KeyPairIdentifier {
        val localVarResponse = postKeyTenantidAliasAliasCategoryHsmcategorySchemeSchemeWithHttpInfo(tenantid = tenantid, alias = alias, hsmcategory = hsmcategory, scheme = scheme)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as net.corda.membership.rest.v1.types.response.KeyPairIdentifier
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * This method generates a new key pair for a tenant.
     * @param tenantid Can either be a holding identity ID, the value &#39;p2p&#39; for a cluster-level tenant of the P2P services, or the value &#39;rest&#39; for a cluster-level tenant of the REST
     * @param alias The alias under which the new key pair will be stored
     * @param hsmcategory Category of the HSM which handles the key pairs. Can be one of &#39;ACCOUNTS&#39;, &#39;CI&#39;, &#39;LEDGER&#39;, &#39;NOTARY&#39;, &#39;SESSION_INIT&#39;, &#39;TLS&#39;, &#39;JWT_KEY&#39;.
     * @param scheme The key&#39;s scheme describing which type of the key pair to generate. For example, &#39;CORDA.RSA&#39;, &#39;CORDA.ECDSA.SECP256K1&#39;, &#39;CORDA.ECDSA.SECP256R1&#39;, &#39;CORDA.EDDSA.ED25519&#39;, &#39;CORDA.SPHINCS-256&#39;.
     * @return ApiResponse<net.corda.membership.rest.v1.types.response.KeyPairIdentifier?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postKeyTenantidAliasAliasCategoryHsmcategorySchemeSchemeWithHttpInfo(tenantid: kotlin.String, alias: kotlin.String, hsmcategory: kotlin.String, scheme: kotlin.String) : ApiResponse<net.corda.membership.rest.v1.types.response.KeyPairIdentifier?> {
        val localVariableConfig = postKeyTenantidAliasAliasCategoryHsmcategorySchemeSchemeRequestConfig(tenantid = tenantid, alias = alias, hsmcategory = hsmcategory, scheme = scheme)

        return request<Unit, net.corda.membership.rest.v1.types.response.KeyPairIdentifier>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postKeyTenantidAliasAliasCategoryHsmcategorySchemeScheme
     *
     * @param tenantid Can either be a holding identity ID, the value &#39;p2p&#39; for a cluster-level tenant of the P2P services, or the value &#39;rest&#39; for a cluster-level tenant of the REST
     * @param alias The alias under which the new key pair will be stored
     * @param hsmcategory Category of the HSM which handles the key pairs. Can be one of &#39;ACCOUNTS&#39;, &#39;CI&#39;, &#39;LEDGER&#39;, &#39;NOTARY&#39;, &#39;SESSION_INIT&#39;, &#39;TLS&#39;, &#39;JWT_KEY&#39;.
     * @param scheme The key&#39;s scheme describing which type of the key pair to generate. For example, &#39;CORDA.RSA&#39;, &#39;CORDA.ECDSA.SECP256K1&#39;, &#39;CORDA.ECDSA.SECP256R1&#39;, &#39;CORDA.EDDSA.ED25519&#39;, &#39;CORDA.SPHINCS-256&#39;.
     * @return RequestConfig
     */
    fun postKeyTenantidAliasAliasCategoryHsmcategorySchemeSchemeRequestConfig(tenantid: kotlin.String, alias: kotlin.String, hsmcategory: kotlin.String, scheme: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/key/{tenantid}/alias/{alias}/category/{hsmcategory}/scheme/{scheme}".replace("{"+"tenantid"+"}", encodeURIComponent(tenantid.toString())).replace("{"+"alias"+"}", encodeURIComponent(alias.toString())).replace("{"+"hsmcategory"+"}", encodeURIComponent(hsmcategory.toString())).replace("{"+"scheme"+"}", encodeURIComponent(scheme.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
