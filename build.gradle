import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import static org.gradle.api.JavaVersion.*

buildscript {
    ext {
        // Remember where our Java executable lives (until Bnd supports Gradle toolchains).
        javaExecutable = file("${System.getProperty('java.home')}/bin/java")
    }
}


plugins {
    id 'net.corda.cordapp.cordapp-configuration'
    id 'org.jetbrains.kotlin.jvm' apply false
    id 'org.jetbrains.kotlin.plugin.allopen' apply false
    id 'org.jetbrains.kotlin.plugin.noarg' apply false
    id 'io.gitlab.arturbosch.detekt' apply false
    id 'org.ajoberstar.grgit' // used for GIT interaction (e.g. extract commit hash)
    id 'com.r3.internal.gradle.plugins.r3ArtifactoryPublish'
    id 'maven-publish'
    id 'jacoco' // test coverage
    id 'com.dorongold.task-tree' // utility to visualise Gradle task DAG
    id 'org.jetbrains.dokka'
}

def rootProjectDir = rootDir
def revision = {
    if (System.getenv("CORDA_REVISION")) {
        return System.getenv("CORDA_REVISION")
    }
    try {
        return "git rev-parse HEAD".execute().text.trim()
    } catch (Exception error) {
        logger.warn("git is unavailable in build environment", error)
        "unknown"
    }
}()

// Ensure that we both compile and run using Kotlin OSGi bundles.
// We must ONLY invoke this for Kotlin's classpath configurations.
void configureKotlinForOSGi(Configuration configuration) {
    configuration.resolutionStrategy {
        dependencySubstitution {
            substitute module('org.jetbrains.kotlin:kotlin-stdlib-jdk8') with module("net.corda.kotlin:kotlin-stdlib-jdk8-osgi:$kotlinVersion")
            substitute module('org.jetbrains.kotlin:kotlin-stdlib-jdk7') with module("net.corda.kotlin:kotlin-stdlib-jdk7-osgi:$kotlinVersion")
            substitute module('org.jetbrains.kotlin:kotlin-stdlib-common') with module("org.jetbrains.kotlin:kotlin-osgi-bundle:$kotlinVersion")
            substitute module('org.jetbrains.kotlin:kotlin-stdlib') with module("org.jetbrains.kotlin:kotlin-osgi-bundle:$kotlinVersion")
            substitute module('org.jetbrains.kotlin:kotlin-reflect') with module("org.jetbrains.kotlin:kotlin-osgi-bundle:$kotlinVersion")
        }
    }
}

def releaseType = System.getenv('RELEASE_TYPE') ?: "SNAPSHOT"
def javaVersion = VERSION_11

logger.quiet("********************** CORDA BUILD **********************")
if (JavaVersion.current() != javaVersion) {
    throw new GradleException("The java version used ${JavaVersion.current()} is not the expected version ${javaVersion}.")
}
logger.quiet("SDK version: {}", JavaVersion.current())
logger.quiet("JAVA HOME {}", System.getProperty("java.home"))
def cordaVersion = "$cordaProductVersion.$cordaApiRevision"
if (System.getenv("RELEASE_VERSION")?.trim()) {
    version = System.getenv("RELEASE_VERSION")
} else {
    def versionSuffix = '-SNAPSHOT'
    if(project.hasProperty('overridePublishVersionSuffix')) {
        versionSuffix = project.property('overridePublishVersionSuffix')
    } else if (System.getenv('VERSION_SUFFIX')) {
        versionSuffix = System.getenv('VERSION_SUFFIX')
    }
    version = "$cordaVersion$versionSuffix"
}

logger.quiet("Corda release version: {}", version)
logger.quiet("Corda baseVersion: {}", cordaVersion)
logger.quiet("Release Type: {}", releaseType)

subprojects {
    buildscript {
        configurations.classpath {
            // FORCE Gradle to use latest SNAPSHOT plugins.
            resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
        }
    }

    version rootProject.version
    group 'net.corda'

    pluginManager.withPlugin('org.jetbrains.kotlin.jvm') {
        apply plugin: 'io.gitlab.arturbosch.detekt'
        apply plugin: 'jacoco'
        apply plugin: 'org.jetbrains.dokka'

        // NOTE: question whether it is "ok" to force dependencies on all modules like this
        //  thinking is that for the test dependencies it's ok as it'll keep things consistent.
        //  we can add exclusions, or review this if necessary.
        dependencies {
            // Test libraries -> keep consistent across modules
            testImplementation "org.jetbrains.kotlin:kotlin-test:$kotlinVersion"
            testImplementation "org.mockito:mockito-core:$mockitoVersion"
            testImplementation("org.mockito.kotlin:mockito-kotlin:$mockitoKotlinVersion") {
                // Excluding mockito-core and adding it implicitly above. This is done to allow the use of the latest version of mockito.
                exclude group: 'mockito-core'
            }

            testImplementation "org.junit.jupiter:junit-jupiter:$junitVersion"

            // Test runtime libraries -> also keep consistent
            testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:$junitVersion"

            detektPlugins "io.gitlab.arturbosch.detekt:detekt-formatting:$detektPluginVersion"
        }

        java {
            sourceCompatibility = javaVersion
            targetCompatibility = javaVersion
        }

        // Making all persistence entity open and with an empty constructor to allow Hibernate to work.
        apply plugin: 'kotlin-allopen'
        allOpen {
            annotations(
                "javax.persistence.Entity",
                "javax.persistence.Embeddable",
                "javax.persistence.MappedSuperclass"
            )
        }
        apply plugin: 'kotlin-noarg'
        noArg {
            annotations(
                "javax.persistence.Entity",
                "javax.persistence.Embeddable",
                "javax.persistence.MappedSuperclass"
            )
        }

        configurations {
            all {
                resolutionStrategy {
                    dependencySubstitution {
                        // Replace any Logback SLF4J back-end with Log4J2.
                        substitute module('ch.qos.logback:logback-classic') using module("org.apache.logging.log4j:log4j-slf4j-impl:$log4jVersion")
                    }
                }
            }

            [ compileClasspath, testCompileClasspath, runtimeClasspath, testRuntimeClasspath ].forEach { cfg ->
                configureKotlinForOSGi(cfg)
            }
        }

        tasks.withType(KotlinCompile).configureEach {
            kotlinOptions {
                allWarningsAsErrors = true
                languageVersion = '1.4'
                apiVersion = '1.4'
                verbose = true
                jvmTarget = javaVersion
                freeCompilerArgs += [
                    "-Xjvm-default=all",
                    // Prevent Kotlin from warning about kotlin.* classes inside the OSGi bundle.
                    "-Xskip-runtime-version-check",
                    "-java-parameters"
                ]
            }
        }

        tasks.withType(JavaCompile).configureEach {
            def compilerArgs = options.compilerArgs
            compilerArgs << '-parameters'

            options.encoding = 'UTF-8'
        }

        // TODO: does this really need to apply to all modules or can this be moved to the modules that need it only?
        tasks.named('compileTestJava', JavaCompile) {
            def compilerArgs = options.compilerArgs
            compilerArgs << '--add-exports'
            compilerArgs << 'java.base/sun.security.x509=ALL-UNNAMED'
            compilerArgs << '--add-exports'
            compilerArgs << 'java.base/sun.security.util=ALL-UNNAMED'
        }

        // TODO: as above, this may not apply to all modules, so maybe should be moved out
        tasks.withType(Jar).matching { it.name != 'cpk' }.configureEach {
            manifest {
                attributes("Corda-Release-Version": archiveVersion.get())
                attributes("Corda-Revision": revision)
                attributes("Automatic-Module-Name": "net.corda.${project.name.replace('-', '.')}")
                // NOTE: this needs to be reverted to a URL with the version once the URL structure has been defined.
//                attributes("Corda-Docs-Link": "https://docs.corda.net/docs/corda-os/$cordaVersion")
                attributes("Corda-Docs-Link": "https://docs.r3.com/")
            }
        }

        // Added to support junit5 tests
        tasks.withType(Test).configureEach {
            useJUnitPlatform()

            doFirst {
                // Create all temporary files within the build directory.
                systemProperty 'java.io.tmpdir', buildDir.absolutePath
            }
        }

        tasks.register('compileAll') { task ->
            description = "Compiles all the Kotlin and Java classes, including all of the test classes."
            group = "verification"

            task.dependsOn tasks.withType(AbstractCompile)
        }

        detekt {
            baseline = file("$projectDir/detekt-baseline.xml")
            config.setFrom(files("$rootProjectDir/detekt-config.yml"))
            parallel = true
            reports {
                xml {
                    enabled = true
                    destination = file("$projectDir/build/detekt-report.xml")
                }
                html {
                    enabled = false
                }
                txt {
                    enabled = false
                }
            }
        }

        tasks.named('jacocoTestReport') {
            def jacocoExecutionDataFiles = fileTree(buildDir).include("/jacoco/*.exec")
            executionData.setFrom(jacocoExecutionDataFiles)

            dependsOn tasks.named('test') // tests are required to run before generating the report

            reports {
                xml.enabled true
                html.enabled true
            }
        }

        tasks.register('javadocJar', Jar) {
            description = 'Create JavaDoc Jar from dokka docs'
            group = 'documentation'

            dependsOn(dokkaHtml)
            archiveBaseName = jar.archiveBaseName
            archiveClassifier.set("javadoc")
            from(dokkaHtml.outputDirectory)
        }
    }
}
