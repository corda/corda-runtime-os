package net.corda.v5.ledger.identity

import net.corda.v5.application.injection.CordaFlowInjectable
import net.corda.v5.application.injection.CordaServiceInjectable
import net.corda.v5.base.annotations.DoNotImplement
import net.corda.v5.base.types.MemberX500Name
import java.security.PublicKey
import java.util.*

/**
 * An identity service maintains a directory of parties by their associated distinguished name/public keys, and thus supports the lookup of
 * a party if given its key or its X.500 name.
 *
 * The service supports two types of identities:
 *
 * - A well-known identity, represented by a [Party] structure, which is a public identity currently or previously registered under
 * the specific X.500 name in the membership group. See [MemberLookup] for retrieving actual and historic well-known identities
 * from the membership group.
 *
 * - A confidential identity, represented by [AnonymousParty] structure, which is only distributed on a "need-to-know" basis (typically
 * between parties in a transaction being built). The service links confidential identity to a particular X.500 name.
 */
@DoNotImplement
interface IdentityService : CordaServiceInjectable, CordaFlowInjectable {

    /**
     * Converts a [PublicKey] of a well-known or confidential identity to X.500 name under which the original identity was registered.
     *
     * @param publicKey [PublicKey] of a well-known or confidential identity.
     *
     * @return X.500 name if identity is known, else returns null.
     */
    fun nameFromKey(publicKey: PublicKey): MemberX500Name?

    /**
     * Creates a new [AnonymousParty] concrete object and returns it out of [publicKey].
     */
    fun anonymousPartyFromKey(publicKey: PublicKey): AnonymousParty

    /**
     * Resolves a party name to the well-known identity [Party] instance for this name. Where possible well-known identity lookup by name
     * should be done using [MemberLookup] instead, as it is the authoritative source of well-known identities.
     *
     * @param name The [MemberX500Name] to determine well known identity for.
     *
     * @return If known the canonical [Party] with that name, else null.
     */
    fun partyFromName(name: MemberX500Name): Party?

    /**
     * Resolves a (optionally) confidential identity to the corresponding well-known identity [Party]. It transparently handles returning
     * the well-known identity back if a (current) well-known identity is passed in. If a historic [Party] is passed in, method returns
     * another [Party] with the same X.500 name but different key, which correspond to the current well-known identity.
     *
     * @param party Identity to determine well-known identity for.
     *
     * @return Well-known identity, if found.
     */
    fun partyFromAnonymous(party: AbstractParty): Party?

    /**
     * Registers a mapping in the database between the provided [PublicKey] and [MemberX500Name] if one does not already exist.
     * If an entry exists for the supplied [PublicKey] but the associated [MemberX500Name] does not match the one supplied to the method
     * then an exception will be thrown.
     *
     * This method also optionally adds a mapping from [PublicKey] to external ID if one is provided. Lastly, the [PublicKey] is also stored
     * (as well as the [PublicKey] hash).
     *
     * @param publicKey The [PublicKey] that will be registered to the supplied [Party].
     * @param name The [MemberX500Name] that the supplied [PublicKey] will be registered to.
     * @param externalId The [UUID] that the supplied public key can be optionally registered to.
     *
     * @throws IllegalArgumentException If the [PublicKey] is already registered to a name that does not match the supplied party.
     */
    fun registerKey(publicKey: PublicKey, name: MemberX500Name, externalId: UUID)

    /**
     * Registers a mapping in the database between the provided [PublicKey] and [MemberX500Name] if one does not already exist.
     * If an entry exists for the supplied [PublicKey] but the associated [MemberX500Name] does not match the one supplied to the method
     * then an exception will be thrown.
     *
     * @param publicKey The [PublicKey] that will be registered to the supplied [Party].
     * @param name The [MemberX500Name] that the supplied [PublicKey] will be registered to.
     *
     * @throws IllegalArgumentException If the [PublicKey] is already registered to a name that does not match the supplied party.
     */
    fun registerKey(publicKey: PublicKey, name: MemberX500Name)

    /**
     * Returns the external ID (as an [UUID]) related to the passed in [PublicKey]. Providing a [PublicKey] that is unknown by the node or
     * is not mapped to an external ID will return null. The method looks up keys generated by the node as well as keys generated on other
     * nodes and registered with the [IdentityService].
     *
     * @param publicKey The [PublicKey] used to perform the lookup to external Id.
     */
    fun externalIdForPublicKey(publicKey: PublicKey): UUID?

    /**
     * Returns the [PublicKey]s which have been mapped to the supplied [externalId].
     *
     * @param externalId The external Id to lookup [PublicKey]s for.
     */
    fun publicKeysForExternalId(externalId: UUID): Iterable<PublicKey>
}
