package net.corda.cipher.suite.internal

import net.corda.crypto.SigningService
import net.corda.internal.crypto.createDevCertificate
import net.corda.internal.crypto.getSigner
import net.corda.crypto.testkit.CryptoMocks
import net.corda.crypto.testkit.MockSignatureVerificationService
import net.corda.v5.cipher.suite.CipherSchemeMetadata
import net.corda.v5.cipher.suite.KeyEncodingService
import net.corda.v5.crypto.CompositeKey
import net.corda.v5.cipher.suite.scheme.KeyScheme
import org.bouncycastle.asn1.x500.X500Name
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Timeout
import org.junit.jupiter.api.io.TempDir
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.MethodSource
import java.nio.file.Files
import java.nio.file.Path
import java.security.KeyStore
import java.util.UUID
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class KeyEncodingServiceTests {
    companion object {
        private lateinit var schemeMetadata: CipherSchemeMetadata
        private lateinit var keyEncoder: KeyEncodingService
        private lateinit var verifier: MockSignatureVerificationService
        private lateinit var signer: SigningService


        @TempDir
        @JvmStatic
        lateinit var tempDir: Path

        @JvmStatic
        fun signatureSchemes(): Array<KeyScheme> = schemeMetadata.keySchemes

        @JvmStatic
        @BeforeAll
        fun setup() {
            schemeMetadata = CipherSchemeMetadataProviderImpl().create()
            val cryptoMocks = CryptoMocks(schemeMetadataImpl = schemeMetadata)
            keyEncoder = schemeMetadata
            verifier = cryptoMocks.signatureVerificationService()
            signer = cryptoMocks.signingService()
        }
    }

    @ParameterizedTest
    @MethodSource("signatureSchemes")
    fun `Should convert public key to PEM and backand and still to able to use for verification`(scheme: KeyScheme) {
        val alias = newAlias()
        val originalPublicKey = signer.generateKeyPair(alias, scheme)
        val encodedPublicKey = keyEncoder.encodeAsString(originalPublicKey)
        assert(encodedPublicKey.startsWith("-----BEGIN PUBLIC KEY-----")) { encodedPublicKey }
        assert(encodedPublicKey.contains("-----END PUBLIC KEY-----")) { encodedPublicKey }
        val decodedPublicKey = keyEncoder.decodePublicKey(encodedPublicKey)
        assertEquals(decodedPublicKey, originalPublicKey)
        val data = UUID.randomUUID().toString().toByteArray(Charsets.UTF_8)
        val signature = signer.sign(decodedPublicKey, data)
        assertTrue(verifier.isValid(decodedPublicKey, signature.bytes, data))
        assertEquals(decodedPublicKey, originalPublicKey)
    }

    @ParameterizedTest
    @MethodSource("signatureSchemes")
    fun `Should convert public key to byte array and back and and still to able to use for verification`(scheme: KeyScheme) {
        val alias = newAlias()
        val originalPublicKey = signer.generateKeyPair(alias, scheme)
        val encodedPublicKey = keyEncoder.encodeAsByteArray(originalPublicKey)
        val decodedPublicKey = keyEncoder.decodePublicKey(encodedPublicKey)
        assertEquals(decodedPublicKey, originalPublicKey)
        val data = UUID.randomUUID().toString().toByteArray(Charsets.UTF_8)
        val signature = signer.sign(decodedPublicKey, data)
        assertTrue(verifier.isValid(decodedPublicKey, signature.bytes, data))
        assertEquals(decodedPublicKey, originalPublicKey)
    }

    @Test
    @Timeout(30)
    fun `Should round trip encode CompositeKey to byte array`() {
        val alicePublicKey = signer.generateKeyPair(newAlias())
        val bobPublicKey = signer.generateKeyPair(newAlias())
        val charliePublicKey = signer.generateKeyPair(newAlias())
        val aliceAndBob = CompositeKey.Builder().addKeys(alicePublicKey, bobPublicKey).build()
        val aliceAndBobOrCharlie = CompositeKey.Builder().addKeys(aliceAndBob, charliePublicKey).build(threshold = 1)
        val encoded = keyEncoder.encodeAsByteArray(aliceAndBobOrCharlie)
        val decoded = keyEncoder.decodePublicKey(encoded)
        assertEquals(decoded, aliceAndBobOrCharlie)
    }

    @Test
    @Timeout(30)
    fun `Should round trip encode CompositeKey to PEM`() {
        val alicePublicKey = signer.generateKeyPair(newAlias())
        val bobPublicKey = signer.generateKeyPair(newAlias())
        val charliePublicKey = signer.generateKeyPair(newAlias())
        val aliceAndBob = CompositeKey.Builder().addKeys(alicePublicKey, bobPublicKey).build()
        val aliceAndBobOrCharlie = CompositeKey.Builder().addKeys(aliceAndBob, charliePublicKey).build(threshold = 1)
        val encoded = keyEncoder.encodeAsString(aliceAndBobOrCharlie)
        val decoded = keyEncoder.decodePublicKey(encoded)
        assertEquals(decoded, aliceAndBobOrCharlie)
    }

    @Test
    @Timeout(30)
    fun `Should round trip encode CompositeKey with weighting to byte array`() {
        val alicePublicKey = signer.generateKeyPair(newAlias())
        val bobPublicKey = signer.generateKeyPair(newAlias())
        val charliePublicKey = signer.generateKeyPair(newAlias())
        val aliceAndBob = CompositeKey.Builder()
                .addKey(alicePublicKey, 2)
                .addKey(bobPublicKey, 1)
                .build(threshold = 2)
        val aliceAndBobOrCharlie = CompositeKey.Builder()
                .addKey(aliceAndBob, 3)
                .addKey(charliePublicKey, 2)
                .build(threshold = 3)
        val encoded = keyEncoder.encodeAsByteArray(aliceAndBobOrCharlie)
        val decoded = keyEncoder.decodePublicKey(encoded)
        assertEquals(decoded, aliceAndBobOrCharlie)
    }

    @Test
    @Timeout(30)
    fun `Should round trip encode CompositeKey with weighting to PEM`() {
        val alicePublicKey = signer.generateKeyPair(newAlias())
        val bobPublicKey = signer.generateKeyPair(newAlias())
        val charliePublicKey = signer.generateKeyPair(newAlias())
        val aliceAndBob = CompositeKey.Builder()
                .addKey(alicePublicKey, 2)
                .addKey(bobPublicKey, 1)
                .build(threshold = 2)
        val aliceAndBobOrCharlie = CompositeKey.Builder()
                .addKey(aliceAndBob, 3)
                .addKey(charliePublicKey, 2)
                .build(threshold = 3)
        val encoded = keyEncoder.encodeAsString(aliceAndBobOrCharlie)
        val decoded = keyEncoder.decodePublicKey(encoded)
        assertEquals(decoded, aliceAndBobOrCharlie)
    }

    @Test
    @Timeout(30)
    fun `Test save to keystore`() {
        val alicePublicKey = signer.generateKeyPair(newAlias())
        val bobPublicKey = signer.generateKeyPair(newAlias())
        val charliePublicKey = signer.generateKeyPair(newAlias())
        val aliceAndBob = CompositeKey.Builder()
                .addKey(alicePublicKey, 2)
                .addKey(bobPublicKey, 1)
                .build(threshold = 2)
        val aliceAndBobOrCharlie = CompositeKey.Builder()
                .addKey(aliceAndBob, 3)
                .addKey(charliePublicKey, 2)
                .build(threshold = 3)
        val caAlias = newAlias()
        val subjectAlias = newAlias()
        val pwdArray = "password".toCharArray()
        val jksFile = Files.createFile(tempDir.resolve("$subjectAlias.jks")).toFile()
        val keyStoreSave = KeyStore.getInstance("JKS")
        keyStoreSave.load(null, pwdArray)
        signer.generateKeyPair(caAlias)
        jksFile.outputStream().use {
            keyStoreSave.setCertificateEntry(subjectAlias, createDevCertificate(
                    issuer = X500Name("CN=ISSUER, O=o, L=L, ST=il, C=c"),
                    contentSigner = signer.getSigner(caAlias),
                    subject = X500Name("CN=SUBJECT, O=o, L=L, ST=il, C=c"),
                    subjectPublicKey = aliceAndBobOrCharlie
            ))
            keyStoreSave.store(it, pwdArray)
        }
        val keyStoreRead = KeyStore.getInstance("JKS")
        val loadedKey = jksFile.inputStream().use {
            keyStoreRead.load(it, pwdArray)
            schemeMetadata.decodePublicKey(keyStoreRead.getCertificate(subjectAlias).publicKey.encoded)
        }
        assertEquals(aliceAndBobOrCharlie, loadedKey)
    }

    private fun newAlias(): String = UUID.randomUUID().toString()
}