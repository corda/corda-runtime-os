buildscript {
    dependencies {
        classpath "biz.aQute.bnd:biz.aQute.bndlib:5.3.0" // Cant' get bndVersion?
        classpath "org.osgi:osgi.core:7.0.0" // Can't get osgiVersion?
    }
}

import java.nio.file.Files
import java.util.jar.JarFile

plugins {
    id 'java'
    id 'corda.publish'
    id 'biz.aQute.bnd.builder'
}

configurations {
    bootstrapClasspath {
        transitive = true
    }
    systemPackages {
        transitive = false
    }
}

dependencies {
    bootstrapClasspath "org.apache.felix:org.apache.felix.framework:$felixVersion"
    bootstrapClasspath "org.jetbrains.kotlin:kotlin-stdlib:$kotlinVersion"
    bootstrapClasspath project(":osgi-framework-bootstrap")

    systemPackages "org.apache.logging.log4j:log4j-api:$log4jVersion"
    systemPackages "org.apache.logging.log4j:log4j-core:$log4jVersion"
    systemPackages "org.apache.logging.log4j:log4j-slf4j-impl:$log4jVersion"
    systemPackages "org.slf4j:slf4j-api:$slf4jVersion"
    systemPackages project(":osgi-framework-bootstrap:framework-api")
}

jar {
    archiveBaseName = project.name
    bnd """
Bundle-Name: $project.description
Bundle-SymbolicName: ${project.group}.${project.name}
-fixupmessages 'Classes found in the wrong directory'; restrict:=error; is:=warning
"""
}

def buildOSGiBundles = tasks.register("buildOSGiBundles") {

    // EXECUTION PRIORITY DEFINITION
    // The *Java* and *Java Library* `classes` task runs after `compileJava` and `processResources`
    // providing the `runtimeClasspath` configuration populated with the dependencies
    // declared by in the `dependencies` block.
    // See https://docs.gradle.org/current/userguide/java_plugin.html
    // See https://docs.gradle.org/current/userguide/java_library_plugin.html
    // The `jar` task runs after the `classes` task.
    // See https://docs.gradle.org/current/dsl/org.gradle.api.tasks.bundling.Jar.html
    dependsOn jar

    doLast {
        println "TASK buildOsgiBundles start..."

        // BUILD RESOURCES
        // Copies artifacts solved as needed dependencies from the `runtimeClasspath` configuration
        // into the directory `resources/main/bundles` part of the *Java* plugin file topology.
        final def bundlesDir = new File(project.buildDir, "resources/main/bundles")
        // Java plugin task `processResources` skips if it doesn't any resource in the `src/main`,
        // hence force the creation of the expected structure of directories if `bundles` dir doesn't exist.
        if (!bundlesDir.exists()) {
            assert bundlesDir.mkdirs()
        }
        final def runtimeClasspath = configurations.getByName("runtimeClasspath")
        final def systemBundlesFile = new File(project.buildDir, "resources/main/system_bundles")

        // SYSTEM BUNDLE CATALOG
        // Artifacts solved as dependencies in the `runtimeClasspath` classpath are scanned to check if those are
        // OSGi bundle.
        final Set<String> systemBundleSet = new TreeSet<>()
        runtimeClasspath.incoming.each { resolvableDependency ->
            resolvableDependency.artifacts.each { resolvedArtifact ->
                final def file = resolvedArtifact.file
                // OSGi bundles must be `.jar` files.
                if (file.name.endsWith(".jar")) {
                    final def jarFile = new JarFile(file)
                    // OSGi bundles must be have `Bundle-SymbolicName` metadata in jar's manifest..
                    if (jarFile.manifest.mainAttributes.getValue("Bundle-SymbolicName") != null) {
                        final def targetPath = new File(bundlesDir, file.name).toPath()
                        Files.deleteIfExists(targetPath)
                        Files.copy(file.toPath(), targetPath)
                        // Describe the OSGi bundle as resource from the root of the classpath, this stratagem allows
                        // JVM to load it indifferently if the resources are loaded by the file system directly,
                        // or if resources are included in a fat jar.
                        systemBundleSet.add("bundles/${file.name}")
                        println "OSGI Bundle $file.name included as resource."
                    }
                }
            }
        }
        // OSGi artifacts built by `jar` task in this module are included as well.
        final def libsDir = new File(project.buildDir, "libs").listFiles().each { file ->
            if (file.name.endsWith(".jar")) {
                final def jarFile = new JarFile(file)
                if (jarFile.manifest.mainAttributes.getValue("Bundle-SymbolicName") != null) {
                    final def targetPath = new File(bundlesDir, file.name).toPath()
                    Files.deleteIfExists(targetPath)
                    Files.copy(file.toPath(), targetPath)
                    systemBundleSet.add("bundles/${file.name}")
                    println "OSGI Bundle $file.name included as resource."
                }
            }
        }
        // Write the `system_bundles` catalog as resource.
        systemBundlesFile.withWriter { writer ->
            systemBundleSet.each { line ->
                writer.writeLine(line)
            }
        }
        final def size = systemBundleSet.size()
        println "TASK buildOsgiBundles included $size OSGi bundles in $systemBundlesFile resource."
    }

}

def buildSystemPackagesExtra = tasks.register("buildSystemPackagesExtra") {
    dependsOn jar
    doLast {
        final Set<String> exportSet = new TreeSet<>()
        configurations.getByName("systemPackages").incoming.each { resolvableDependency ->
            resolvableDependency.artifacts.each { resolvedArtifact ->
                new JarFile(resolvedArtifact.file, true, JarFile.OPEN_READ, JarFile.runtimeVersion()).withCloseable { jarFile ->
                    if (jarFile.manifest.mainAttributes.getValue(org.osgi.framework.Constants.BUNDLE_SYMBOLICNAME) != null) {
                        jarFile.manifest.mainAttributes.getValue(org.osgi.framework.Constants.EXPORT_PACKAGE)?.with { exportPackage ->
                            aQute.bnd.header.OSGiHeader.parseHeader(exportPackage).entrySet().each { exportEntry ->
                                final def export = exportEntry.key + ";" + exportEntry.value.toString()
                                exportSet.add(export)
                                println "OSGI $export included as extra system package."
                            }
                        }
                    } else {
                        jarFile.versionedStream().filter { jarEntry ->
                            jarEntry.name.endsWith(".class")
                        }.each { jarEntry ->
                            String entryName = jarEntry.name
                            int end = entryName.lastIndexOf('/')
                            if (end > 0) {
                                final def export = entryName.substring(0, end).replace('/', '.')
                                exportSet.add(export)
                                println "OSGI $export included as extra system package."
                            }
                        }
                    }
                }
            }
        }
        final systemPackagesExtraFile = new File(project.buildDir, "resources/main/system_packages_extra")
        Files.deleteIfExists(systemPackagesExtraFile.toPath())
        systemPackagesExtraFile.withWriter { writer ->
            exportSet.each { export -> writer.writeLine(export) }
        }
        println "OSGI extra system packages list $systemPackagesExtraFile included as resource."
    }
}

// Build a self-sufficient bootable jar with Apache Felix and `bootstrapClasspath` embedded.
// The dependencies built as OSGi bundles are zipped in the `bundles` directory,
// The OSGi dependencies are listed in the `system_bundles` file zipped in bootable jar.
// NOTE
// The bootable jar is built in the `project.buildDir + "boot"` directory.
def buildBootJar = tasks.register("buildBootJar", Jar) {
    dependsOn buildOSGiBundles, buildSystemPackagesExtra
    archivesBaseName = project.name + ".boot"
    destinationDirectory = new File(project.buildDir, "boot")
    from(
            configurations.bootstrapClasspath.collect { it.isDirectory() ? it : zipTree(it) },
            configurations.systemPackages.collect { it.isDirectory() ? it : zipTree(it) },
            new File(project.buildDir, "resources/main")
    )
    manifest {
        attributes 'Main-Class': 'net.corda.osgi.framework.OSGiFrameworkMain'
    }
}


