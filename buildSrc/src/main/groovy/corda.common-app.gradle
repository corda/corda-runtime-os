import java.util.jar.JarFile

plugins {
    id 'java'
    id 'corda.publish'
    id 'biz.aQute.bnd.builder'
}

configurations {

}

compileKotlin {
    kotlinOptions.jvmTarget = jvmTarget
}

compileTestKotlin {
    kotlinOptions.jvmTarget = jvmTarget
}

//def buildAppJar = tasks.register("buildAppJar", Jar) {
//    inputs.files(project(":osgi-framework-bootstrap:framework-api").jar)
//    archiveBaseName = project.name
//    archiveVersion = version
//    ["compileJava", "compileKotlin", "processResources"].each { taskName ->
//        inputs.files(tasks.named(taskName))
//    }
//    manifest {
//        attributes 'Main-Class': 'net.corda.osgi.framework.OSGiFrameworkMain'
//        attributes 'Can-Redefine-Classes': true
//        attributes 'Can-Retransform-Classes': true
//    }
//    from(sourceSets.main.output.files)
//    ['appJarRuntimeClasspath'].each { configurationName ->
//        from { configurations[configurationName].collect { it.isDirectory() ? it : zipTree(it) } }
//    }
//}
//build.dependsOn(buildAppJar)

//tasks.register("run", JavaExec) {
//    mainClass = 'net.corda.osgi.framework.OSGiFrameworkMain'
//    classpath(sourceSets.main.output)
//    classpath(project.configurations.named('appJarRuntimeClasspath'))
//}

///**
// * Scan the OSGi bundles of the Corda project to bundle them in the `build/resource/main/bundles` directory of the project,
// * list the bundles in the `build/resource/main/system_bundles` files to allow classloader to load them from IDE (file system)
// * or packed in the executable fat jar.
// */
//Provider<Copy> buildOsgiBundles = tasks.register("buildOsgiBundles", Copy) {
//    final def bundlesDir = new File(project.buildDir, "resources/main/bundles")
//    final def systemBundlesFile = new File(project.buildDir, "resources/main/system_bundles")
//
//    into bundlesDir
//    from configurations.osgiBundle
//    doLast {
//        final Set<String> systemBundleSet = new TreeSet<>()
//        bundlesDir.listFiles({ File dir, String name -> name.endsWith(".jar") } as FilenameFilter)
//                .grep { File file ->
//                    new JarFile(file).manifest.mainAttributes.getValue("Bundle-SymbolicName")
//                }.each { file ->
//            systemBundleSet.add("bundles/${file.name}")
//        }
//        systemBundlesFile.withWriter { writer ->
//            systemBundleSet.each { line ->
//                writer.writeLine(line)
//            }
//        }
//    }
//}


///**
// * Scan the OSGi bundles defined in 'systemPackages' and 'quasar' configuration,
// * scan the packages declared in the and `systemPackagesExtra` array of this `build.gradle`
// * and export them through the `system_packages_extra` property of the OSGI framework.
// */
//class BuildSystemPackageExtra extends DefaultTask {
//
//    BuildSystemPackageExtra() {
//        sourceConfigurations = project.objects.listProperty(String.class)
//        jdkExtraPackages = project.objects.listProperty(String.class)
//        systemPackagesExtraFile = project.objects.fileProperty()
//    }
//
//    @Input
//    final ListProperty<String> sourceConfigurations
//
//    @Input
//    final ListProperty<String> jdkExtraPackages
//
//    @InputFiles
//    FileCollection getInputFiles() {
//        FileCollection result = project.objects.fileCollection()
//        sourceConfigurations.map { list ->
//            list.forEach { configurationName ->
//                result.add(project.configurations[configurationName])
//            }
//        }
//        return result
//    }
//
//    @OutputFile
//    final RegularFileProperty systemPackagesExtraFile
//
//    @TaskAction
//    def run() {
//        final Set<String> exportSet = new TreeSet<>()
//        sourceConfigurations.get().each { configurationName ->
//            project.configurations[configurationName].incoming.each { resolvableDependency ->
//                resolvableDependency.artifacts.each { resolvedArtifact ->
//                    final def jarFile = new JarFile(resolvedArtifact.file)
//                    if (jarFile.manifest.mainAttributes.getValue("Bundle-SymbolicName") != null) {
//                        jarFile.manifest.mainAttributes.getValue("Export-Package")?.with { exportPackage ->
//                            OSGiHeader.parseHeader(exportPackage).entrySet().each { exportEntry ->
//                                final def export = exportEntry.key + ";" + exportEntry.value.toString()
//                                exportSet.add(export)
//                            }
//                        }
//                    } else {
//                        jarFile.entries().each { jarEntry ->
//                            if (jarEntry.name.endsWith(".class")) {
//                                final def list = jarEntry.name.replace('\\', '/').split('/').toList()
//                                final def export = list.subList(0, list.size() - 1).join('.')
//                                exportSet.add(export)
//                            }
//                        }
//                    }
//                }
//            }
//        }
//        jdkExtraPackages.get().each { export -> exportSet.add(export) }
//        systemPackagesExtraFile.getAsFile().get().withWriter { writer ->
//            exportSet.each { export -> writer.writeLine(export) }
//        }
//    }
//}

//Provider<BuildSystemPackageExtra> buildSystemPackagesExtra = tasks.register("buildSystemPackagesExtra", BuildSystemPackageExtra) {
//    sourceConfigurations = ['systemPackages']
//    jdkExtraPackages = [
//    ]
//    systemPackagesExtraFile = project.layout.buildDirectory.file("resources/main/system_packages_extra")
//}

//tasks.named("processResources") {
//    inputs.files(buildSystemPackagesExtra, buildOsgiBundles)
//}

Provider<Copy> bundleOSGiDependencies = tasks.register("bundleOSGiDependencies", Copy) {

    // EXECUTION PRIORITY DEFINITION
    // The *Java* and *Java Library* `classes` task runs after `compileJava` and `processResources`
    // providing the `runtimeClasspath` configuration populated with the dependencies
    // declared by in the `dependencies` block.
    // See https://docs.gradle.org/current/userguide/java_plugin.html
    // See https://docs.gradle.org/current/userguide/java_library_plugin.html
    dependsOn([tasks.classes, tasks.processResources])
    // This task runs after the `classes` task and before the `jar` task to select the OSGi bundles needed by the
    // `runtimeClasspath` configuration.

    println "TASK buildOsgiBundles start..."
    // COPY TASK EXTENSION
    // Copies artifacts solved as needed dependencies from the `runtimeClasspath` configuration
    // into the directory `resources/main/bundles` part of the *Java* plugin file topology.
    final def bundlesDir = new File(project.buildDir, "resources/main/bundles")
    // Java plugin task `processResources` skips if it doesn't any resource in the `src/main`,
    // hence force the creation of the expected structure of directories if `bundles` dir doesn't exist.
    if (!bundlesDir.exists()) {
        assert bundlesDir.mkdirs()
    }
    final def runtimeClasspath = configurations.getByName("runtimeClasspath")
    final def systemBundlesFile = new File(project.buildDir, "resources/main/system_bundles")
    from runtimeClasspath
    into bundlesDir

    // SYSTEM BUNDLE CATALOG
    // Artifacts solved as dependencies in the `runtimeClasspath` classpath are scanned to check if those are
    // OSGi bundle.
    final Set<String> systemBundleSet = new TreeSet<>()
    runtimeClasspath.incoming.each { resolvableDependency ->
        resolvableDependency.artifacts.each { resolvedArtifact ->
            final def file = resolvedArtifact.file
            // OSGi bundles must be `.jar` files.
            if (file.name.endsWith(".jar")) {
                final def jarFile = new JarFile(file)
                // OSGi bundles must be have `Bundle-SymbolicName` metadata in jar's manifest..
                if (jarFile.manifest.mainAttributes.getValue("Bundle-SymbolicName") != null) {
                    // Describe the OSGi bundle as resource from the root of the classpath, this stratagem allows
                    // JVM to load it indifferently if the resources are loaded by the file system directly,
                    // or if resources are included in a fat jar.
                    systemBundleSet.add("bundles/${file.name}")
                    println "OSGI Bundle $file.name included as resource."
                }
            }
        }
    }
    // Write the `system_bundles` catalog as resource.
    systemBundlesFile.withWriter { writer ->
        systemBundleSet.each { line ->
            writer.writeLine(line)
        }
    }
    final def size = systemBundleSet.size()
    println "TASK buildOsgiBundles included $size OSGi bundles in $systemBundlesFile resource."

}

jar {
    dependsOn bundleOSGiDependencies
//    manifest {
//        attributes 'Main-Class': 'net.corda.osgi.framework.OSGiFrameworkMain'
//    }
}

